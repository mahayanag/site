<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Introdução aos modelos lineares mistos para os estudos da linguagem</title>
  <meta name="description" content="Introdução aos modelos lineares mistos para os estudos da linguagem" />
  <meta name="generator" content="bookdown 0.17 and GitBook 2.6.7" />

  <meta property="og:title" content="Introdução aos modelos lineares mistos para os estudos da linguagem" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Introdução aos modelos lineares mistos para os estudos da linguagem" />
  
  
  

<meta name="author" content="Mahayana C. Godoy (PPgEL/UFRN)" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="assets/jquery-2.2.3/jquery.min.js"></script>
<link href="assets/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="..." type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path=""><a href="#apresentação-objetivo-público-alvo-e-conteúdo"><i class="fa fa-check"></i>Apresentação: objetivo, público alvo e conteúdo</a></li>
<li class="chapter" data-level="1" data-path=""><a href="#introdução-ao-r-manipulação-e-visualização-de-dados"><i class="fa fa-check"></i><b>1</b> Introdução ao R: manipulação e visualização de dados</a><ul>
<li class="chapter" data-level="1.1" data-path=""><a href="#reprodutibilidade-na-ciência"><i class="fa fa-check"></i><b>1.1</b> Reprodutibilidade na ciência</a></li>
<li class="chapter" data-level="1.2" data-path=""><a href="#r-rstudio-e-seu-ambiente-de-programação"><i class="fa fa-check"></i><b>1.2</b> R, RStudio e seu Ambiente de Programação</a></li>
<li class="chapter" data-level="1.3" data-path=""><a href="#como-o-r-funciona"><i class="fa fa-check"></i><b>1.3</b> Como o R funciona</a></li>
<li class="chapter" data-level="1.4" data-path=""><a href="#manipulando-conjuntos-de-dados"><i class="fa fa-check"></i><b>1.4</b> Manipulando conjuntos de dados</a><ul>
<li class="chapter" data-level="1.4.1" data-path=""><a href="#dataframes-importando-e-conhecendo-seu-conjunto-de-dados"><i class="fa fa-check"></i><b>1.4.1</b> Dataframes: importando e conhecendo seu conjunto de dados</a></li>
<li class="chapter" data-level="1.4.2" data-path=""><a href="#dataframes-manipulando-seu-conjunto-de-dados"><i class="fa fa-check"></i><b>1.4.2</b> Dataframes: manipulando seu conjunto de dados</a></li>
<li class="chapter" data-level="1.4.3" data-path=""><a href="#dataframes-extraindo-informações-descritivas-de-seus-dados"><i class="fa fa-check"></i><b>1.4.3</b> Dataframes: extraindo informações descritivas de seus dados</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path=""><a href="#explorando-dados-graficamente-ggplot2"><i class="fa fa-check"></i><b>1.5</b> Explorando dados graficamente: ggplot2</a><ul>
<li class="chapter" data-level="1.5.1" data-path=""><a href="#ggplot-sintaxe-básica"><i class="fa fa-check"></i><b>1.5.1</b> ggplot: Sintaxe Básica</a></li>
<li class="chapter" data-level="1.5.2" data-path=""><a href="#gráficos-de-dispersão"><i class="fa fa-check"></i><b>1.5.2</b> Gráficos de dispersão</a></li>
<li class="chapter" data-level="1.5.3" data-path=""><a href="#boxplots"><i class="fa fa-check"></i><b>1.5.3</b> Boxplots</a></li>
<li class="chapter" data-level="1.5.4" data-path=""><a href="#gráfico-de-barras"><i class="fa fa-check"></i><b>1.5.4</b> Gráfico de barras</a></li>
<li class="chapter" data-level="1.5.5" data-path=""><a href="#não-pare-por-aqui"><i class="fa fa-check"></i><b>1.5.5</b> Não pare por aqui!</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path=""><a href="#prática"><i class="fa fa-check"></i><b>1.6</b> Prática</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path=""><a href="#modelos-lineares"><i class="fa fa-check"></i><b>2</b> Modelos Lineares</a><ul>
<li class="chapter" data-level="2.1" data-path=""><a href="#modelos-lineares-sintaxe-em-r-e-conceitos-básicos"><i class="fa fa-check"></i><b>2.1</b> Modelos lineares: sintaxe em R e conceitos básicos</a></li>
<li class="chapter" data-level="2.2" data-path=""><a href="#os-coeficientes-do-modelo-linear"><i class="fa fa-check"></i><b>2.2</b> Os coeficientes do modelo linear</a></li>
<li class="chapter" data-level="2.3" data-path=""><a href="#modelos-lineares-com-efeitos-fixos-categóricos"><i class="fa fa-check"></i><b>2.3</b> Modelos lineares com efeitos fixos categóricos</a></li>
<li class="chapter" data-level="2.4" data-path=""><a href="#modelos-lineares-e-outros-testes-estatísticos"><i class="fa fa-check"></i><b>2.4</b> Modelos lineares e outros testes estatísticos</a></li>
<li class="chapter" data-level="2.5" data-path=""><a href="#modelos-lineares-com-mais-de-uma-variável"><i class="fa fa-check"></i><b>2.5</b> Modelos lineares com mais de uma variável</a></li>
<li class="chapter" data-level="2.6" data-path=""><a href="#hipóteses-do-modelo"><i class="fa fa-check"></i><b>2.6</b> Hipóteses do modelo</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path=""><a href="#modelos-lineares-mistos-conceitos-básicos"><i class="fa fa-check"></i><b>3</b> Modelos Lineares Mistos: conceitos básicos</a><ul>
<li class="chapter" data-level="3.1" data-path=""><a href="#medidas-repetidas-e-efeitos-aleatórios"><i class="fa fa-check"></i><b>3.1</b> Medidas repetidas e efeitos aleatórios</a><ul>
<li class="chapter" data-level="3.1.1" data-path=""><a href="#inspeção-e-limpeza-dos-dados"><i class="fa fa-check"></i><b>3.1.1</b> Inspeção e limpeza dos dados</a></li>
<li class="chapter" data-level="3.1.2" data-path=""><a href="#modelo-linear-misto-interceptos-e-slopes-aleatórios"><i class="fa fa-check"></i><b>3.1.2</b> Modelo linear misto: interceptos e slopes aleatórios</a></li>
<li class="chapter" data-level="3.1.3" data-path=""><a href="#modelos-lineares-mistos-no-pacote-lme4"><i class="fa fa-check"></i><b>3.1.3</b> Modelos lineares mistos no pacote lme4</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path=""><a href="#comparação-por-modelos-aninhados"><i class="fa fa-check"></i><b>3.2</b> Comparação por modelos aninhados</a></li>
<li class="chapter" data-level="3.3" data-path=""><a href="#modelos-lineares-mistos-com-duas-variáveis-e-interação"><i class="fa fa-check"></i><b>3.3</b> Modelos lineares mistos com duas variáveis e interação</a></li>
<li class="chapter" data-level="3.4" data-path=""><a href="#slopes-e-efeitos-aleatórios"><i class="fa fa-check"></i><b>3.4</b> Slopes e efeitos aleatórios</a></li>
<li class="chapter" data-level="3.5" data-path=""><a href="#distribuição-dos-dados-transformação-logarítmica"><i class="fa fa-check"></i><b>3.5</b> Distribuição dos dados: transformação logarítmica</a></li>
<li class="chapter" data-level="3.6" data-path=""><a href="#resumindo-o-modelo-linear-misto"><i class="fa fa-check"></i><b>3.6</b> Resumindo o modelo linear misto</a></li>
<li class="chapter" data-level="3.7" data-path=""><a href="#prática-1"><i class="fa fa-check"></i><b>3.7</b> Prática</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path=""><a href="#modelos-lineares-mistos-contrastes-e-testes-post-hoc"><i class="fa fa-check"></i><b>4</b> Modelos lineares mistos: contrastes e testes post-hoc</a><ul>
<li class="chapter" data-level="4.1" data-path=""><a href="#tabela-de-coeficientes-em-mlms-com-interação"><i class="fa fa-check"></i><b>4.1</b> Tabela de coeficientes em MLMs com interação</a></li>
<li class="chapter" data-level="4.2" data-path=""><a href="#efeito-simples-e-efeito-principal"><i class="fa fa-check"></i><b>4.2</b> Efeito simples e efeito principal</a></li>
<li class="chapter" data-level="4.3" data-path=""><a href="#contrastes"><i class="fa fa-check"></i><b>4.3</b> Contrastes</a></li>
<li class="chapter" data-level="4.4" data-path=""><a href="#análises-post-hoc"><i class="fa fa-check"></i><b>4.4</b> Análises <em>post-hoc</em></a></li>
<li class="chapter" data-level="4.5" data-path=""><a href="#prática-contrastes-e-testes-post-hoc"><i class="fa fa-check"></i><b>4.5</b> Prática: contrastes e testes post-hoc</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path=""><a href="#modelos-lineares-generalizados-mistos"><i class="fa fa-check"></i><b>5</b> Modelos lineares generalizados mistos</a><ul>
<li class="chapter" data-level="5.1" data-path=""><a href="#a-distribuição-binomial"><i class="fa fa-check"></i><b>5.1</b> A distribuição binomial</a></li>
<li class="chapter" data-level="5.2" data-path=""><a href="#probabilidades-e-chances-odds"><i class="fa fa-check"></i><b>5.2</b> Probabilidades e chances (<em>odds</em>)</a></li>
<li class="chapter" data-level="5.3" data-path=""><a href="#regressão-logística-e-log-odds"><i class="fa fa-check"></i><b>5.3</b> Regressão logística e <em>log-odds</em></a></li>
<li class="chapter" data-level="5.4" data-path=""><a href="#modelos-lineares-generalizados-mistos-mlgms"><i class="fa fa-check"></i><b>5.4</b> Modelos Lineares Generalizados Mistos (MLGMs)</a></li>
<li class="chapter" data-level="5.5" data-path=""><a href="#modelos-lineares-generalizados-outras-distribuições"><i class="fa fa-check"></i><b>5.5</b> Modelos lineares generalizados: outras distribuições</a></li>
<li class="chapter" data-level="5.6" data-path=""><a href="#prática-modelos-lineares-generalizados"><i class="fa fa-check"></i><b>5.6</b> Prática: modelos lineares generalizados</a></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#referências"><i class="fa fa-check"></i>Referências</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Introdução aos modelos lineares mistos para os estudos da linguagem</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="header">
<h1 class="title">Introdução aos modelos lineares mistos para os estudos da linguagem</h1>
<p class="author"><em>Mahayana C. Godoy (PPgEL/UFRN)</em></p>
</div>
<div id="apresentação-objetivo-público-alvo-e-conteúdo" class="section level1 unnumbered">
<h1>Apresentação: objetivo, público alvo e conteúdo</h1>
<blockquote>
<p><strong>Para citar este material:</strong></p>
<p>Godoy, M. C. (2019). Introdução aos modelos lineares mistos para os estudos da linguagem. PsyArXiv. <a href="https://doi.org/10.17605/OSF.IO/9T8UR" class="uri">https://doi.org/10.17605/OSF.IO/9T8UR</a></p>
</blockquote>
<p>Este tutorial foi pensado com o objetivo de ensinar os conceitos básicos de Modelos Lineares Mistos e sua implementação em <code>R</code> no ambiente do RStudio. Apesar de haver muitos tutoriais bons sobre o tema em inglês, há pouco material desse tipo produzido em português para acadêmicos que têm pouca familiaridade com estatística. Por isso, o tutorial foi pensado para um público de pesquisadores em Ciências Humanas que têm pouco ou nenhum contato com linguagem de programação e pouco conhecimento de estatística. Para acompanhar o tutorial por conta própria, você deve conhecer os conceitos de média, mediana e distribuição normal. Além disso, fica mais fácil se você souber como funciona um histograma e um boxplot.</p>
<p>Se você tem conhecimento avançado em estatística ou está procurando uma discussão mais profunda sobre aspectos matemáticos de modelos lineares, esse tutorial talvez não seja para você. Se você é um pesquisador com um pouco de conhecimento sobre testes de hipóteses, mas que não domina o conceito básico de modelo linear, esse material é para você. O tutorial também é útil caso você conheça o básico de modelos lineares e queira aprender a utilizar <code>R</code> para fazer suas análises.</p>
<p>Modelos lineares são empregados para lidar com uma gama muito ampla de problemas de pesquisa. Os exemplos que serão dados nesses tutoriais refletem o tipo de pesquisa que eu realizo e conheço melhor: dados experimentais coletados em pesquisa sobre processamento de linguagem. Por isso, tenha sempre em mente que há uma série de questões que não abordarei (amostragem, detecção de outliers, desenhos experimentais etc.) que têm tratamentos específicos em áreas diferentes. Conheça bem a literatura da sua área antes de planejar uma análise de dados.</p>
<p>Ainda que os exemplos e dados sejam específicos de uma área, o conceito básico de modelo linear pode ser generalizado para outros campos.</p>
<p>Para acompanhar o tutorial, você deverá</p>
<ul>
<li><p>instalar o <code>R</code>: <a href="https://cran.r-project.org/" class="uri">https://cran.r-project.org/</a></p></li>
<li><p>instalar o RStudio: <a href="https://www.rstudio.com/products/rstudio/download/" class="uri">https://www.rstudio.com/products/rstudio/download/</a></p></li>
<li><p>baixar os arquivos do curso: <a href="https://github.com/mahayanag/tutoriaRmlm" class="uri">https://github.com/mahayanag/tutoriaRmlm</a></p></li>
</ul>
<p>A primeira seção é uma introdução ao <code>R</code> e ao RStudio e aos pacotes <code>ggplot2</code> e <code>dplyr</code>. Se você já é usuário de <code>R</code> e conhece os pacotes, pode seguir para a segunda seção.</p>
<p>Se encontrar algum erro no material, entre em contato através do e-mail <code>mahayanag -at- gmail</code> ou por <code>@mahagodoy</code> no twitter.</p>
</div>
<div id="introdução-ao-r-manipulação-e-visualização-de-dados" class="section level1">
<h1><span class="header-section-number">1</span> Introdução ao R: manipulação e visualização de dados</h1>
<p>O conteúdo desta seção inclui:</p>
<ol style="list-style-type: decimal">
<li><p>Reprodutibilidade na ciência</p></li>
<li><p>R, RStudio e seu ambiente de programação</p></li>
<li><p>Manipulação de dados usando o pacote dplyr</p></li>
<li><p>Gráficos utilizando o pacote ggplot2</p></li>
</ol>
<div id="reprodutibilidade-na-ciência" class="section level2">
<h2><span class="header-section-number">1.1</span> Reprodutibilidade na ciência</h2>
<p>Na Psicologia Cognitiva, há grande debate sobre a replicabilidade dos resultados de experimentos. Muitos trabalhos não têm conseguido replicar achados amplamente divulgados na academia e na mídia, o que tem feito com que a comunidade científica busque maneiras de melhorar nossas práticas experimentais<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. No contexto do que hoje chamamos de <strong><em>Open Science</em></strong>, há uma necessidade crescente de promover a transparência dos procedimentos de criação de hipóteses, coleta e análise dos resultados experimentais.</p>
<p>Podemos deixar nossos estudos mais transparentes criando <strong>pré-registro</strong><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> dos nossos procedimentos de coleta e análise de dados. Podemos também compartilhar nosso conjunto de dados para permitir que outros pesquisadores reproduzam nossas análises de dados e/ou identifiquem padrões ou erros que não percebemos. Ter seu trabalho questionado por outro cientista não é algo ruim ou indesejado. Pelo contrário: significa que alguém leu o que você produziu e achou interessante o suficiente para identificar erros e propôr soluções que podem ampliar a compreensão do fenômeno estudado.</p>
<p>Hoje, há uma série de programas disponíveis para realização de análises estatísticas, como Excel, SPSS, STATA, Minitab etc. Se a seção de análise de dados de um artigo é bem escrita, ela deve ter informações que permitam a reprodução de seus resultados por outra pessoa que queira usar qualquer um desses programas. No entanto, as análises feitas a partir desses programas seguem um procedimento de <em>point-and-click</em>, o que torna mais difícil (e demorada) a reprodução das análises se algum detalhe deixou de ser descrito.</p>
<p>Nesse contexto, o uso de <strong>linguagens de programação</strong> apresenta a vantagem de permitir a reprodutibilidade das análises realizadas de modo mais transparente e mais fácil, sem custos maiores para quem está auditando a análise. Ao compartilharmos nosso código, fica fácil para nossos pares (pareceristas ou não) seguirem todos os passos da nossa análise e identificarem possíveis erros. O uso de linguagens de programação também permite que anotemos nossas decisões no próprio código. Isso permite que, anos depois, lembremos porque tomamos determinadas decisões durante nossa análise.</p>
<p>Embora haja outras linguagens de programação que podem ser usadas para análise de dados, esse tutorial elege o <code>R</code>. Para entender um pouco como essa linguagem funciona, precisamos conhecer também o RStudio, o ambiente de programação que usaremos ao longo do tutorial.</p>
</div>
<div id="r-rstudio-e-seu-ambiente-de-programação" class="section level2">
<h2><span class="header-section-number">1.2</span> R, RStudio e seu Ambiente de Programação</h2>
<p>Nesse tutorial, usamos o ambiente RStudio para escrever e rodar nossos códigos. Ele é uma interface que permite escrever o código e ver seus resultados em quatro paineis diferentes.</p>
<p>A cada novo grande trabalho de análise de dados (um mestrado, um doutorado, uma consultoria específica, um artigo etc.), é recomendado que você crie um <strong>novo projeto</strong> no R, uma espécie de pasta para reunir os arquivos de dados e códigos de análise desse projeto específico. Vamos aprender a fazer isso agora, criando um projeto para esse tutorial.</p>
<p>Abra o RStudio. Se tudo deu certo, você verá uma imagem parecida com a <strong>Figura 1.1</strong>.</p>
<div align="center">
<p><br></p>
<div class="figure">
<img src="images/RStudio.png" alt="Figura 1.1 Tela do RStudio" style="width:70.0%" />
<p class="caption"><strong>Figura 1.1</strong> Tela do RStudio</p>
</div>
<p><br></p>
</div>

<p>Vá em <code>File &gt; New Project</code> e selecione <em>New Directory</em> para criar um diretório novo (cf. <strong>Figura 1.2</strong>).</p>
<div align="center">
<div class="figure">
<img src="images/NewDirectory.png" alt="Figura 1.2 Criando projeto em Novo diretório" style="width:50.0%" />
<p class="caption"><strong>Figura 1.2</strong> Criando projeto em Novo diretório</p>
</div>
</div>
<p>Vamos criar um novo projeto no R, uma pasta onde colocaremos todos os arquivos necessários para o curso. Para isso, selecione <em>Empty Project</em> (cf. <strong>Figura 1.3</strong>).</p>
<div align="center">
<div class="figure">
<img src="images/EmptyProject.png" alt="Figura 1.3 Selecionando a opção Empty Project" style="width:50.0%" />
<p class="caption"><strong>Figura 1.3</strong> Selecionando a opção <em>Empty Project</em></p>
</div>
</div>
<p>Em seguida, escolha a pasta onde você vai guardar desse projeto e escolha um nome para ele (eu o chamei de TutoriaRMLM e guardei na minha pasta de <code>cursos</code>, como você vê na <strong>Figura 1.4</strong>).</p>
<div align="center">
<div class="figure">
<img src="images/TutoriaR_script.png" alt="Figura 1.4 Nomear novo diretório" style="width:50.0%" />
<p class="caption"><strong>Figura 1.4</strong> Nomear novo diretório</p>
</div>
</div>
<p>Importe para essa nova pasta os materiais do tutorial que você baixou. São eles:</p>
<ol style="list-style-type: lower-alpha">
<li><p>a pasta <code>dados</code>, com os conjuntos de dados que utilizaremos;</p></li>
<li><p>a pasta <code>scripts</code>, que contem os códigos em arquivo <code>.R</code> para acompanhar cada seção do tutorial e a pasta <code>tarefas</code>, com os gabaritos e respostas das tarefas práticas de cada seção;</p></li>
<li><p>a pasta <code>arquivos_html</code>, que apresenta cada uma das seções deste tutorial em formato <code>html</code>, para quem preferir acompanhar numa versão visualmente mais agradável.</p></li>
</ol>
<p>Após importar todos os conjuntos de dados, você verá que as pastas <code>dados</code>, <code>scripts</code> e <code>arquivos_html</code> agora estão na aba <code>Files</code> no painel inferior direito do RStudio (cf. <strong>Figura 1.5</strong>). Se não estiverem lá, é porque você não colocou as pastas dentro do arquivo correto. Confira esse passo.</p>
<p><br></p>
<div align="center">
<div class="figure">
<img src="images/InicialProjeto.png" alt="Figura 1.5 Tela inicial do novo projeto" style="width:70.0%" />
<p class="caption"><strong>Figura 1.5</strong> Tela inicial do novo projeto</p>
</div>
</div>
<p><br></p>
<p>Para abrir um script de extensão <code>.R</code>, que é um script de código executável em <code>R</code>, basta ir na pasta em que eles estão e abrir. Vamos abrir aqui o script da primeira seção do tutorial, chamado <code>Aula1_MLM.R</code>. Clique na pasta de scripts dentro do RStudio e abra-o.</p>
<p><br></p>
<div align="center">
<div class="figure">
<img src="images/TelaInicial.png" alt="Figura 1.6 Tela inicial do tutorial" style="width:70.0%" />
<p class="caption"><strong>Figura 1.6</strong> Tela inicial do tutorial</p>
</div>
</div>
<p><br></p>
<p>Ao abrir o script, você viu que sua tela ficou dividia em quatro painéis. Tomando a <strong>Figura 1.6</strong> como referência, temos:</p>
<ul>
<li><p><strong>Canto superior esquerdo:</strong> aqui temos o editor de texto. Vamos escrever nossos códigos nesta área. Quando fizer um script novo, você pode criá-lo ao apertar as teclas Ctrl+Shift+N. Para salvar, faça o mesmo que você faria para um documento de word (Crtl+Shift+S ou File&gt;Save) e salve sempre dentro do projeto R em que você está trabalhando.</p></li>
<li><p><strong>Canto inferior esquerdo:</strong> é o chamado <em>prompt</em>. Quando você roda um comando no editor de texto, é no <em>prompt</em> que os comandos são rodados e é aí que você vê os resultados se for algo numérico.</p></li>
<li><p><strong>Canto superior direito:</strong> possui as abas <em>Environment</em>, <em>History</em>, <em>Connections</em> e <em>Build</em>. A mais usada é a aba Environment, onde podemos verificar quais variáveis estão presentes na memória do programa.</p></li>
<li><p><strong>Canto inferior direito:</strong> possui diversas abas chamadas <em>Files</em>, <em>Plots</em>, <em>Packages</em>, <em>Help</em> e <em>Viewer</em>. É neste painel que veremos os gráficos plotados e os arquivos de ajuda.</p></li>
</ul>
<p>Em um projeto R, a aba <em>Files</em> mostra os arquivos presentes na pasta. Para você voltar ao diretório anterior nessa aba, clique nos dois pontos ao lado da flecha verde que fica acima da lista de arquivos. Faça isso para voltar ao diretório raiz do projeto R que acabamos de criar.</p>
<p>Agora que você já está com o script da primeira seção aberto, podemos ver como o <code>R</code> funciona.</p>
</div>
<div id="como-o-r-funciona" class="section level2">
<h2><span class="header-section-number">1.3</span> Como o R funciona</h2>
<p>As primeiras linhas do seu código tratam da instalação de dois pacotes que são usados na primeira seção deste tutorial: <code>dplyr</code> e <code>ggplot2</code>. O <code>R</code> é uma linguagem de programação que executa funções que você escreve ou que estão previstas em um de seus inúmeros <strong>pacotes</strong>. Alguns pacotes servem para análise estatística, outros para manipulação ou viasualização de dados, alguns para produzir apresentações de <em>slides</em>, documentos em html ou pdf (o material deste tutorial foi todo feito com <code>R</code>!). Usamos a função <code>install.packages()</code> para instalar os dois pacotes que vamos usar nesta seção. Para executar o código, deixe o cursor (aquela barrinha vertical que fica piscando) na linha do comando que deseja executar e aperte CTRL+ENTER.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## baixar pacotes

<span class="kw">install.packages</span>(<span class="st">&quot;dplyr&quot;</span>)
<span class="kw">install.packages</span>(<span class="st">&quot;ggplot2&quot;</span>)</code></pre></div>
<p>Uma vez que você baixe um pacote do <code>R</code>, você não precisa mais instalá-lo (a menos que você formate o computador ou que saia uma versão atualizada do pacote). No entanto, toda vez que você iniciar uma seção nova do <code>RStudio</code> ou do <code>R</code>, você precisará carregar os pacotes através da função <code>library()</code>. Como sabemos que vamos usar esses pacotes mais adiante no tutorial, já vamos carregá-los aqui (para fins de organização, é sempre bom deixar no topo do seu código todos os pacotes que precisam ser carregados ao longo do trabalho).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## carregar pacotes

<span class="kw">library</span>(dplyr)
<span class="kw">library</span>(ggplot2)</code></pre></div>
<p>Quando organizamos nossos códigos, é importante comentá-los para que outras pessoas (e nós mesmos) entendamos o que está sendo feito ali. Para criar um comentário (ou seja, uma linha que não é entendida como um código executável), você precisa iniciar a linha com o símbolo <code>#</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Tudo que for precedido pelo símbolo # em uma linha é classificado como  comentário

## Comentários não são entendidos como código, e portanto o programa não tentará 
## executá-los</code></pre></div>
<p>O código executável é inserido em um linha nova, e seu output mostrado em um dos dois paineis da parte inferior da tela. Abaixo vamos executar a equação 2+2. Como o resultado dela é um valor numérico, aparecerá na aba <em>prompt</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Essa linha é um comentário. A linha abaixo é um comando. Deixe o cursor (aquela 
## barrinha vertical que fica piscando) na linha do comando que deseja 
## executar e aperte CTRL+ENTER. Tente fazer isso com o comando da linha abaixo.

<span class="dv">2+2</span>
<span class="co">#&gt; [1] 4</span></code></pre></div>
<p>Acima, fizemos uma operação matemática. Podemos fazer operações matemáticas a partir de funções. Por exemplo, abaixo usamos a função <code>sqrt()</code> para calcular a raiz quadrada de <code>4</code>. Dizemos aqui que <em>4 é o argumento da função sqrt()</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## calculando a raiz quadrada de 4

<span class="kw">sqrt</span>(<span class="dv">4</span>)
<span class="co">#&gt; [1] 2</span></code></pre></div>
<p>A função <code>c(x, y, z)</code> cria um vetor com os elementos x, y e z. Os códigos abaixo criam um vetor chamado <code>idade</code> com a idade de 4 pessoas e um vetor chamado <code>nome</code> com os nomes de 4 pessoas (quando criar vetores não-numéricos, não se esqueça de colocar o valor entre aspas duplas, como <code>&quot;x&quot;</code>).</p>
<p>Ao criar esses vetores, você verá que eles aparecem como um novo <strong>objeto</strong> na área <em>Environment</em>, à esquerda.</p>
<blockquote>
<p><strong>ATENÇÃO!</strong> Para criar um novo objeto <code>x</code> que contenha o resultado de uma função, você pode usar <code>&lt;-</code>, como em <code>x &lt;- f(y)</code> ou <code>=</code>, como em <code>x = f(y)</code>.</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## criando um vetor com 4 valores

idade &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">34</span>, <span class="dv">35</span>, <span class="dv">39</span>, <span class="dv">42</span>)

## criar um vetor com 4 nomes

nomes &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;José&quot;</span>, <span class="st">&quot;Maria&quot;</span>, <span class="st">&quot;Ana&quot;</span>, <span class="st">&quot;Pedro&quot;</span>)</code></pre></div>
<p>Algumas das funções mais comuns são <code>mean()</code>, <code>median()</code> e <code>sd()</code>, que retornam a média, mediana e desvio-padrão de um conjunto de dados. A seguir, extraímos a média, mediana e desvio padrão do conjunto de dados <code>idade</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## extraindo a média de idade

<span class="kw">mean</span>(idade)
<span class="co">#&gt; [1] 37.5</span>

## extraindo a mediana de idade

<span class="kw">median</span>(idade)
<span class="co">#&gt; [1] 37</span>

## extraindo o desvio-padrão de idade

<span class="kw">sd</span>(idade)
<span class="co">#&gt; [1] 3.696846</span></code></pre></div>
<p>Quando tentamos extrair as mesmas informações da coluna <code>nome</code>, recebemos uma mensagem de erro: <code>argument is not numeric or logical: returning NA[1] NA</code>. Isso ocorre porque o argumento dessas funções deve ter natureza numérica, e a mensagem de erro nos diz que esse não é o caso para o vetor <code>nomes</code>.</p>
<blockquote>
<p><strong>ATENÇÃO!</strong> Sempre que receber uma mensagem de erro ao rodar seu código, leia-a atentamente. Ela geralmente te informa o que há de errado com seu código. Se você não souber interpretá-la, jogue-a no google: alguém já teve sua dúvida.</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## extraindo a média de nomes

<span class="kw">mean</span>(nomes)
<span class="co">#&gt; Warning in mean.default(nomes): argument is not numeric or logical: returning NA</span>
<span class="co">#&gt; [1] NA</span>

## extraindo a mediana de nomes

<span class="kw">median</span>(nomes)
<span class="co">#&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): argument</span>
<span class="co">#&gt; is not numeric or logical: returning NA</span>
<span class="co">#&gt; [1] NA</span>

## extraindo o desvio-padrão de nomes

<span class="kw">sd</span>(nomes)
<span class="co">#&gt; Warning in var(if (is.vector(x) || is.factor(x)) x else as.double(x), na.rm =</span>
<span class="co">#&gt; na.rm): NAs introduced by coercion</span>
<span class="co">#&gt; [1] NA</span></code></pre></div>
<p>É possível salvar o resultado de qualquer função em um objeto de nome a sua escolha, e esses objetos são salvos na área <em>Environment</em>. Não use espaços, acentos e caracteres especiais no nome. Para não se confundir, não use maiúsculas: o R diferencia maísculas de minúsculas.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## criando um objeto com os resultados de uma função

media =<span class="st"> </span><span class="kw">mean</span>(idade)
mediana =<span class="st"> </span><span class="kw">median</span>(idade)
desvio.padrao =<span class="st"> </span><span class="kw">sd</span>(idade)

## inspecionando os objetos criados

media
<span class="co">#&gt; [1] 37.5</span>
mediana
<span class="co">#&gt; [1] 37</span>
desvio.padrao
<span class="co">#&gt; [1] 3.696846</span></code></pre></div>
</div>
<div id="manipulando-conjuntos-de-dados" class="section level2">
<h2><span class="header-section-number">1.4</span> Manipulando conjuntos de dados</h2>
<p>Até agora usamos o <code>R</code> como calculadora de contas simples, mas é claro que não é esse o uso que fazemos dele. Quando fazemos uma análise estatística, geralmente seguimos alguns passos:</p>
<ol style="list-style-type: lower-alpha">
<li>arrumamos os dados em um conjunto de dados, geralmente uma planilha;</li>
<li>inspecionamos os dados para ver a distribuição de dados;</li>
<li>excluímos alguns dados que julgamos relevante suprimir;</li>
<li>fazemos uma análise estatística dos dados.</li>
</ol>
<p>Vamos começar pelo primeiro passo, entendendo exatamente o que é uma planilha e como podemos importá-la para o <code>R</code>.</p>
<div id="dataframes-importando-e-conhecendo-seu-conjunto-de-dados" class="section level3">
<h3><span class="header-section-number">1.4.1</span> Dataframes: importando e conhecendo seu conjunto de dados</h3>
<p>Anteriormente, criamos um <strong>vetor</strong> chamado <code>idade</code> e um chamado <code>nome</code>. Um vetor é uma lista de elementos, todos do mesmo tipo. Com o comando <code>data.frame()</code>, podemos unir esses dois vetores em um <strong><em>dataframe</em></strong>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## criando um dataframe

df =<span class="st"> </span><span class="kw">data.frame</span>(nomes, idade)</code></pre></div>
<p>Você pode clicar no objeto <code>df</code> que acabamos de criar e verá que ele é uma tabela composta pelos dois vetores que tínhamos anteriormente. Para aplicar uma função a um vetor específico de um <em>dataframe</em>, usamos o símbolo <code>$</code>. Abaixo, conseguimos extrair a média do vetor <code>idade</code> do <em>dataframe</em> chamado <code>df</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## média de idade

<span class="kw">median</span>(df$idade)
<span class="co">#&gt; [1] 37</span></code></pre></div>
<p>Geralmente, quando trabalhamos com conjuntos de dados, eles estão organizados em <em>dataframes</em>. Para aprendermos a importar <em>dataframes</em> para o <code>R</code>, manipulá-los e extrair suas informações, vamos usar o conjunto de dados <code>linguistas.csv</code>. Esse conjunto de dados tem informações sobre os linguistas de 4 universidades (UFRN, UFMG e Unicamp) e foi coletado em julho de 2019. Como ele tem extensão <code>.csv</code>, vamos importá-lo usando a função <code>read.csv()</code>. Perceba que o argumento da função é o “endereço” do arquivo: ele está dentro da pasta <em>dados</em>, e por isso o argumento da função é <code>&quot;dados/linguistas.csv&quot;</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## criando o conjunto de dados chamado linguistas.total com todos os dados da planilha 
## linguistas.csv

linguistas.total =<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;dados/linguistas.csv&quot;</span>)</code></pre></div>
<blockquote>
<p><strong>ATENÇÃO!</strong> Para importar conjuntos de dados com outra extensão, como <code>.xlsx</code> ou <code>.txt</code>, você precisará usar outras funções, mas de uma maneira semelhante a que acabamos de fazer. No nosso tutorial usaremos apenas arquivos <code>.csv</code>.</p>
</blockquote>
<p>Agora que importamos o conjunto de dados, vamos ver o seu conteúdo. Você pode fazer isso usando uma das opções abaixo:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">

## Use a função head() para ver as linhas iniciais do conjunto de dados

<span class="kw">head</span>(linguistas.total)
<span class="co">#&gt;      genero idade altura altura.2 peso tamanho.pe instituicao  dialeto</span>
<span class="co">#&gt; 1  Feminino    33    157      157   54         35        UFRN  Bolacha</span>
<span class="co">#&gt; 2  Feminino    23    167      167   67         36     Unicamp  Bolacha</span>
<span class="co">#&gt; 3  Feminino    49    158      158   50         33        UFMG Biscoito</span>
<span class="co">#&gt; 4  Feminino    23    164      164   54         36        UFMG Biscoito</span>
<span class="co">#&gt; 5 Masculino    28    166      166   75         38     Unicamp  Bolacha</span>
<span class="co">#&gt; 6 Masculino    24    174      174   57         41        UFMG Biscoito</span>
<span class="co">#&gt;                deslocamento    status esporte</span>
<span class="co">#&gt; 1 veículo próprio ou carona professor     Sim</span>
<span class="co">#&gt; 2 veículo próprio ou carona     aluno     Não</span>
<span class="co">#&gt; 3 veículo próprio ou carona     aluno     Sim</span>
<span class="co">#&gt; 4                     outro     aluno     Sim</span>
<span class="co">#&gt; 5                      à pé     aluno     Sim</span>
<span class="co">#&gt; 6        transporte público     aluno     Não</span>

## Use a função str() para conhecer o conjunto de dados (informação sobre número de 
## níveis, se o vetor é numérico ou não)

<span class="kw">str</span>(linguistas.total)
<span class="co">#&gt; &#39;data.frame&#39;:    67 obs. of  11 variables:</span>
<span class="co">#&gt;  $ genero      : Factor w/ 2 levels &quot;Feminino&quot;,&quot;Masculino&quot;: 1 1 1 1 2 2 1 2 1 1 ...</span>
<span class="co">#&gt;  $ idade       : int  33 23 49 23 28 24 41 35 53 33 ...</span>
<span class="co">#&gt;  $ altura      : int  157 167 158 164 166 174 160 172 163 167 ...</span>
<span class="co">#&gt;  $ altura.2    : int  157 167 158 164 166 174 160 172 163 167 ...</span>
<span class="co">#&gt;  $ peso        : int  54 67 50 54 75 57 60 85 58 64 ...</span>
<span class="co">#&gt;  $ tamanho.pe  : int  35 36 33 36 38 41 36 42 36 38 ...</span>
<span class="co">#&gt;  $ instituicao : Factor w/ 4 levels &quot;Outra&quot;,&quot;UFMG&quot;,..: 3 4 2 2 4 2 4 4 2 3 ...</span>
<span class="co">#&gt;  $ dialeto     : Factor w/ 2 levels &quot;Biscoito&quot;,&quot;Bolacha&quot;: 2 2 1 1 2 1 2 1 2 1 ...</span>
<span class="co">#&gt;  $ deslocamento: Factor w/ 4 levels &quot;à pé&quot;,&quot;outro&quot;,..: 4 4 4 2 1 3 4 1 3 3 ...</span>
<span class="co">#&gt;  $ status      : Factor w/ 2 levels &quot;aluno&quot;,&quot;professor&quot;: 2 1 1 1 1 1 2 2 1 1 ...</span>
<span class="co">#&gt;  $ esporte     : Factor w/ 2 levels &quot;Não&quot;,&quot;Sim&quot;: 2 1 2 2 2 1 1 2 2 2 ...</span>

## Clique no conjunto na área Environment para abrir o conjunto de dados em forma de 
## planilha</code></pre></div>
<p>Esse conjunto de dados contém 11 variáveis:</p>
<blockquote>
<p><code>genero</code>: gênero do participante (apenas participantes de dois gêneros tiveram interesse em responder o questionário)</p>
</blockquote>
<blockquote>
<p><code>idade</code>: idade do participante</p>
</blockquote>
<blockquote>
<p><code>altura</code>: altura do participante em cm</p>
</blockquote>
<blockquote>
<p><code>altura.2</code>: repetição da coluna altura</p>
</blockquote>
<blockquote>
<p><code>peso</code>: peso do participante em kg</p>
</blockquote>
<blockquote>
<p><code>tamanho.pe</code>: número do calçado do participante</p>
</blockquote>
<blockquote>
<p><code>instituicao</code>: instituição onde o participante estuda/trabalha</p>
</blockquote>
<blockquote>
<p><code>dialeto</code>: se o participante se refere a um pacote de passatempo como biscoito ou bolacha</p>
</blockquote>
<blockquote>
<p><code>deslocamento</code>: como o participante se desloca até a universidade</p>
</blockquote>
<blockquote>
<p><code>status</code>: posição do participante na universidade</p>
</blockquote>
<blockquote>
<p><code>esporte</code>: se o participante pratica esportes</p>
</blockquote>
</div>
<div id="dataframes-manipulando-seu-conjunto-de-dados" class="section level3">
<h3><span class="header-section-number">1.4.2</span> Dataframes: manipulando seu conjunto de dados</h3>
<p>Imagine que queremos conhecer a população de linguistas da UFRN, Unicamp e UFMG. Primeiro precisamos garantir que haja apenas linguistas dessas instituições na nossa tabela. Além disso, queremos apenas participantes sejam alunos ou professores dessas instituições. A função <code>unique()</code> nos ajuda a ver os valores únicos do vetor de um <em>dataframe</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## usando a função unique para ver todos os valores únicos da coluna *instituicao* no 
## conjunto de dados

<span class="kw">unique</span>(linguistas.total$instituicao)
<span class="co">#&gt; [1] UFRN    Unicamp UFMG    Outra  </span>
<span class="co">#&gt; Levels: Outra UFMG UFRN Unicamp</span>

## usando a função unique para ver todos os valores únicos da coluna *status* no 
## conjunto de dados

<span class="kw">unique</span>(linguistas.total$status)
<span class="co">#&gt; [1] professor aluno    </span>
<span class="co">#&gt; Levels: aluno professor</span></code></pre></div>
<p>Nosso primeiro problema será excluir a ocorrência de pessoas de outras instituições. Já que vamos limpar o conjunto de dados, também convém excluir a coluna <code>altura.2</code>, que é uma replicação da coluna <code>altura</code>.</p>
<p>Para fazer essas duas tarefas, usaremos o pacote <code>dplyr</code>, que nos ajuda a selecionar colunas e linhas a nossa escolha, criar tabelas para resumir os dados, mudar o formato do <em>dataframe</em> e várias outras funções. O <code>dplyr</code> possui funções bastante simples, mas que se usadas <strong>recursivamente</strong>, produzem resultados bastante variados.</p>
<p>As funções que vamos usar são:</p>
<ul>
<li><code>select</code>: seleciona variáveis baseada em seus nomes (colunas)</li>
<li><code>filter</code>: selecionas casos baseados em seus valores (linhas)</li>
<li><code>summarise</code>: resume múltiplos valores a apenas um</li>
<li><code>group_by</code>: agrupa dados para realizar operações</li>
</ul>
<p>Vamos começar com a função <code>select()</code> para selecionar todas as colunas que usaremos, <em>exceto</em> a coluna <code>altura.2</code>. Rode o código abaixo e perceba que o resultado é a mesma planilha que tínhamos antes, mas sem a coluna <code>altura.2</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## selecionando apenas as colunas de interesse para o projeto

linguistas.total%&gt;%
<span class="st">  </span><span class="kw">select</span>(genero, idade, altura, peso, tamanho.pe, instituicao, dialeto, deslocamento, 
         status, esporte)</code></pre></div>
<pre><code>#&gt;      genero idade altura peso tamanho.pe instituicao  dialeto
#&gt; 1  Feminino    33    157   54         35        UFRN  Bolacha
#&gt; 2  Feminino    23    167   67         36     Unicamp  Bolacha
#&gt; 3  Feminino    49    158   50         33        UFMG Biscoito
#&gt; 4  Feminino    23    164   54         36        UFMG Biscoito
#&gt; 5 Masculino    28    166   75         38     Unicamp  Bolacha
#&gt; 6 Masculino    24    174   57         41        UFMG Biscoito
#&gt;                deslocamento    status esporte
#&gt; 1 veículo próprio ou carona professor     Sim
#&gt; 2 veículo próprio ou carona     aluno     Não
#&gt; 3 veículo próprio ou carona     aluno     Sim
#&gt; 4                     outro     aluno     Sim
#&gt; 5                      à pé     aluno     Sim
#&gt; 6        transporte público     aluno     Não</code></pre>
<p>Se você prestar atenção ao código, verá que usando uma nova função, representada pelo símbolo <code>%&gt;%</code>. Essa função se chama <em>pipe</em> e serve para levar o output de um comando para outro. Dito de outro modo, dizemos que o <em>pipe</em> pega o resultado de uma linha do código e usa como <em>input</em> para a função que está na linha subsequente. No exemplo acima, a primeira linha apenas seleciona o conjunto de dados <code>linguistas.total</code>, e a esse resultado aplica a função <code>select()</code>.</p>
<p>Para entender o que o <em>pipe</em> faz, analisemos mais um exemplo. Dessa vez queremos filtrar apenas as informações de linguistas da UFRN, Unicamp e UFMG. Para isso, usamos o <em>pipe</em> com a função <code>filter</code>. A linha de <code>filter</code> do código abaixo pode ser lida como:</p>
<ul>
<li><em>filtre selecionando as observações que, na coluna <code>instituicao</code>, tenham valor igual a “UFRN”, ou que na coluna <code>instituicao</code>, tenham valor igual a “UFMG”, ou que na coluna <code>instituicao</code>, tenham valor igual a “Unicamp”</em></li>
</ul>
<p>Note que o símbolo <code>|</code>, no código abaixo, corresponde ao operador lógico <code>ou</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># selecionando apenas participantes que indicaram que trabalham/estudam na Unicamp</span>
## *OU* na UFMG *OU* na UFRN

## Marcador | indica &quot;ou&quot;

linguistas.total%&gt;%
<span class="st">  </span><span class="kw">filter</span>(instituicao ==<span class="st"> &quot;UFRN&quot;</span> |<span class="st"> </span>instituicao ==<span class="st"> &quot;UFMG&quot;</span> |<span class="st"> </span>instituicao ==<span class="st"> &quot;Unicamp&quot;</span>)</code></pre></div>
<pre><code>#&gt;      genero idade altura altura.2 peso tamanho.pe instituicao  dialeto
#&gt; 1  Feminino    33    157      157   54         35        UFRN  Bolacha
#&gt; 2  Feminino    23    167      167   67         36     Unicamp  Bolacha
#&gt; 3  Feminino    49    158      158   50         33        UFMG Biscoito
#&gt; 4  Feminino    23    164      164   54         36        UFMG Biscoito
#&gt; 5 Masculino    28    166      166   75         38     Unicamp  Bolacha
#&gt; 6 Masculino    24    174      174   57         41        UFMG Biscoito
#&gt;                deslocamento    status esporte
#&gt; 1 veículo próprio ou carona professor     Sim
#&gt; 2 veículo próprio ou carona     aluno     Não
#&gt; 3 veículo próprio ou carona     aluno     Sim
#&gt; 4                     outro     aluno     Sim
#&gt; 5                      à pé     aluno     Sim
#&gt; 6        transporte público     aluno     Não</code></pre>
<p>Ao rodar o código acima, você verá que permaneceram na planilha de resultado apenas as observações de linguistas cujo valor da coluna <code>instituicao</code> era “UFMG”, “UFRN” e “Unicamp”.</p>
<p>Outra maneira de pedirmos a mesma seleção, obtendo o mesmo resultado, é informando que queremos a seleção de qualquer valor na coluna instituição que seja <em>diferente de</em> “Outra”. Rode o código abaixo e perceba que o resultado é o mesmo que obtivemos com o código anterior.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Selecionando participantes de todas as universidades diferentes de Outra

linguistas.total%&gt;%
<span class="st">  </span><span class="kw">filter</span>(instituicao !=<span class="st"> &quot;Outra&quot;</span>)</code></pre></div>
<pre><code>#&gt;      genero idade altura altura.2 peso tamanho.pe instituicao  dialeto
#&gt; 1  Feminino    33    157      157   54         35        UFRN  Bolacha
#&gt; 2  Feminino    23    167      167   67         36     Unicamp  Bolacha
#&gt; 3  Feminino    49    158      158   50         33        UFMG Biscoito
#&gt; 4  Feminino    23    164      164   54         36        UFMG Biscoito
#&gt; 5 Masculino    28    166      166   75         38     Unicamp  Bolacha
#&gt; 6 Masculino    24    174      174   57         41        UFMG Biscoito
#&gt;                deslocamento    status esporte
#&gt; 1 veículo próprio ou carona professor     Sim
#&gt; 2 veículo próprio ou carona     aluno     Não
#&gt; 3 veículo próprio ou carona     aluno     Sim
#&gt; 4                     outro     aluno     Sim
#&gt; 5                      à pé     aluno     Sim
#&gt; 6        transporte público     aluno     Não</code></pre>
<blockquote>
<p><strong>ATENÇÃO!</strong> Note que o sinal <code>==</code> indica “igual a” na seleção por meio do <em>pipe</em>, enquando o sinal <code>!=</code> indica <em>diferente de</em>.</p>
</blockquote>
<p>É possível combinar <code>filter</code> e <code>select</code> em uma sequência de comandos, sempre sabendo que o resultado de uma linha <code>n</code>, através do <em>pipe</em>, será o <em>input</em> de uma linha subsequente <code>n+1</code>. Vejamos isso no próximo código, em que também pedimos para excluir uma pessoa que indicou 78 como número de calçado, o que é obviamente um erro.</p>
<p>O código abaixo opera da seguinte maneira:</p>
<ul>
<li><p>Linha 1: busca o conjunto de dados <code>linguistas.total</code></p></li>
<li><p>Linha 2: toma o resultado da Linha 1 seleciona as colunas de interesse (excluindo <code>altura.2</code>)</p></li>
<li><p>Linha 3: toma o resultado da Linha 2 e, em cima dele, aplica a função <code>filter()</code> para filtrar apenas observações de participantes cuja <code>instituicao</code> tenha valor diferente de “Outra”;</p></li>
<li><p>Linha 4: toma o resultado da Linha 3 e filtra observações que na coluna <code>tamanho.pe</code> tenha valor menor que 50.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Selecionando as colunas de interesse
## Selecionando participantes de instituições diferentes de Outra
## Selecionando participantes com tamanho de calçado menor que 50

linguistas.total%&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(genero, idade, altura, peso, tamanho.pe, instituicao, dialeto, deslocamento, 
         status, esporte)%&gt;%
<span class="st">  </span><span class="kw">filter</span>(instituicao !=<span class="st"> &quot;Outra&quot;</span>)%&gt;%
<span class="st">  </span><span class="kw">filter</span>(tamanho.pe &lt;<span class="st"> </span><span class="dv">50</span>)</code></pre></div>
<pre><code>#&gt;      genero idade altura peso tamanho.pe instituicao  dialeto
#&gt; 1  Feminino    33    157   54         35        UFRN  Bolacha
#&gt; 2  Feminino    23    167   67         36     Unicamp  Bolacha
#&gt; 3  Feminino    49    158   50         33        UFMG Biscoito
#&gt; 4  Feminino    23    164   54         36        UFMG Biscoito
#&gt; 5 Masculino    28    166   75         38     Unicamp  Bolacha
#&gt; 6 Masculino    24    174   57         41        UFMG Biscoito
#&gt;                deslocamento    status esporte
#&gt; 1 veículo próprio ou carona professor     Sim
#&gt; 2 veículo próprio ou carona     aluno     Não
#&gt; 3 veículo próprio ou carona     aluno     Sim
#&gt; 4                     outro     aluno     Sim
#&gt; 5                      à pé     aluno     Sim
#&gt; 6        transporte público     aluno     Não</code></pre>
<p>Agora que selecionamos apenas as observações que queríamos, vamos salvar esse novo conjunto de dados com o nome de <code>linguistas.edit</code>. Na última linha do código, ainda usamos a função <code>droplevels</code> para que, nesse novo conjunto, sejam apagados os registros dos níveis que foram descartados a partir do filtros criados.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Criando conjunto de dados

linguistas.edit =<span class="st"> </span>linguistas.total%&gt;%
<span class="st">  </span><span class="kw">select</span>(genero, idade, altura, peso, tamanho.pe, instituicao, dialeto, deslocamento, 
         status, esporte)%&gt;%
<span class="st">  </span><span class="kw">filter</span>(instituicao !=<span class="st"> &quot;Outra&quot;</span>)%&gt;%
<span class="st">  </span><span class="kw">filter</span>(tamanho.pe &lt;<span class="st"> </span><span class="dv">70</span>)%&gt;%
<span class="st">  </span><span class="kw">droplevels</span>()</code></pre></div>
<p>Ao rodar o código, você verá o conjunto de dados linguistas.edit na sua área <em>Environment</em>.</p>
<p>É muito comum precisarmos limpar nosso conjunto de dados antes de analisá-los. Quando precisar fazer isso, evite criar planilhas diferentes para cada nova limpeza que precise fazer. O mais adequado é fazer as seleções e filtragens com o <code>dplyr</code>, comentando o porquê das escolhas. Se você preferir criar planilhas novas para cada filtragem, no futuro não saberá o que são todas aquelas planilhas.</p>
<p>Acredite em mim: é essa a minha sensação ao ver a <strong>Figura 1.7</strong>, que mostra a pasta com os dados de um experimento do meu mestrado.</p>
<div align="center">
<div class="figure">
<img src="images/mestrado.png" alt="Figura 1.7 Pasta desorganizada com arquivos incompreensíveis" style="width:60.0%" />
<p class="caption"><strong>Figura 1.7</strong> Pasta desorganizada com arquivos incompreensíveis</p>
</div>
</div>
<div id="tarefa-1-manipulação-do-conjunto-de-dados" class="section level4">
<h4><span class="header-section-number">1.4.2.1</span> Tarefa 1: manipulação do conjunto de dados</h4>
<ul>
<li><p>Olhe os códigos abaixo sem rodá-los;</p></li>
<li><p>Tente descobrir que código gerará uma mensagem de erro e o motivo dessa mensagem;</p></li>
<li><p>Rode os códigos para ver se você acertou.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Código 1
linguistas.total%&gt;%
<span class="st">  </span><span class="kw">select</span>(genero, idade, altura, esporte, tamanho.pe, status)%&gt;%
<span class="st">  </span><span class="kw">filter</span>(instituicao !=<span class="st"> &quot;UFMG&quot;</span>)

## Código 2
linguistas.total%&gt;%
<span class="st">  </span><span class="kw">select</span>(genero, idade, altura, instituicao, esporte, status)%&gt;%
<span class="st">  </span><span class="kw">filter</span>(instituicao !=<span class="st"> &quot;UFMG&quot;</span>)</code></pre></div>
</div>
</div>
<div id="dataframes-extraindo-informações-descritivas-de-seus-dados" class="section level3">
<h3><span class="header-section-number">1.4.3</span> Dataframes: extraindo informações descritivas de seus dados</h3>
<p>Antes mesmo de fazermos nossa análise, é útil olharmos nossos dados para extrairmos algumas medidas descritivas: médias, medianas, desvio-padrão, contagem, porcentagem etc. Para aplicar funções estatísticas nas colunas do conjunto de dados e gerar tabelas com estatística descritiva, utilizamos a função <code>summarise</code>. O raciocício é o mesmo que usamos até aqui: o <em>pipe</em> recebe o resultado de uma linha e usa como <em>input</em> da linha seguinte.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Criando tabela com as médias de altura e tamanho de pé a partir do conjunto 
## linguistas.edit

linguistas.edit%&gt;%
<span class="kw">summarise</span>(<span class="kw">mean</span>(altura),
          <span class="kw">mean</span>(tamanho.pe))
<span class="co">#&gt;   mean(altura) mean(tamanho.pe)</span>
<span class="co">#&gt; 1     166.0328         37.47541</span>

## Mesmo resultado, mas com etiquetas

linguistas.edit%&gt;%
<span class="kw">summarise</span>(<span class="dt">media_altura =</span> <span class="kw">mean</span>(altura),
          <span class="dt">media_pe     =</span> <span class="kw">mean</span>(tamanho.pe))
<span class="co">#&gt;   media_altura media_pe</span>
<span class="co">#&gt; 1     166.0328 37.47541</span></code></pre></div>
<p>Acima, os dois códigos retornam os mesmos valores: a média de altura é de 166cm, e a média do tamanho do pé é 37.4. A única diferença é que no segundo código decidimos nomear esses valores que estamos extraindo com os nomes <code>media_altura</code> e <code>media_pe</code>. Desse jeito nossos dados ficam mais organizados.</p>
<p>A função <code>summarise</code> fica mais interessante se utilizada em conjunto com <code>group_by</code>. Essa última função agrupa as observações de acordo com os níveis de uma variável categórica. Veja que, com o código abaixo, primeiro pedimos para agrupar os dados pelos valores de <code>instituição</code> (ou seja, pelas níveis <code>UFRN</code>, <code>UFMG</code> e <code>Unicamp</code>), e depois pedimos para extrair as médias de altura e tamanho de pé (<code>mean()</code>), e também para calcular o número de ocorrências (<code>n()</code>) em cada um desses níveis.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Criando tabela agrupando os participantes por instituição e para extração das médias 
## de altura e tamanho de pé e do número de participantes

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">media_altura =</span> <span class="kw">mean</span>(altura),
            <span class="dt">media_pe     =</span> <span class="kw">mean</span>(tamanho.pe),
            <span class="dt">quantidade   =</span> <span class="kw">n</span>())
<span class="co">#&gt; # A tibble: 3 x 4</span>
<span class="co">#&gt;   instituicao media_altura media_pe quantidade</span>
<span class="co">#&gt;   &lt;fct&gt;              &lt;dbl&gt;    &lt;dbl&gt;      &lt;int&gt;</span>
<span class="co">#&gt; 1 UFMG                166.     37.4         28</span>
<span class="co">#&gt; 2 UFRN                165.     37.4         17</span>
<span class="co">#&gt; 3 Unicamp             168.     37.8         16</span></code></pre></div>
<p>Para quem trabalha em áreas em que é preciso cruzar informação de diversos níveis para fazer contagem de ocorrências (ou extrair sua estatística descritiva), a função <code>summary()</code> é uma excelente maneira de extrair tabelas que resumam os dados, pois permite a seleção de combinação de múltiplas variáveis. Vamos extrair a quantidade participantes por instituição e gênero.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Criando tabelas agrupando participantes por instituição e gênero para saber 
## o n de cada grupo

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao, genero)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">qtdd =</span> <span class="kw">n</span>())
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt; # Groups:   instituicao [3]</span>
<span class="co">#&gt;   instituicao genero     qtdd</span>
<span class="co">#&gt;   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1 UFMG        Feminino     20</span>
<span class="co">#&gt; 2 UFMG        Masculino     8</span>
<span class="co">#&gt; 3 UFRN        Feminino     11</span>
<span class="co">#&gt; 4 UFRN        Masculino     6</span>
<span class="co">#&gt; 5 Unicamp     Feminino      8</span>
<span class="co">#&gt; 6 Unicamp     Masculino     8</span></code></pre></div>
<div id="tarefa-descrição-dos-dados" class="section level4">
<h4><span class="header-section-number">1.4.3.1</span> Tarefa: descrição dos dados</h4>
<p>É possível combinar as funções que vimos até agora em um mesmo código. Olhe os códigos abaixo, tente adivinhar qual seria seu <em>output</em> e crie uma descrição para eles .</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Código 1
linguistas.total%&gt;%
<span class="st">  </span><span class="kw">filter</span>(instituicao ==<span class="st"> &quot;Unicamp&quot;</span>)%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(genero)%&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">media =</span> <span class="kw">mean</span>(altura))

## Código 2
linguistas.total%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(status, deslocamento)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">qtt =</span> <span class="kw">n</span>())</code></pre></div>
</div>
</div>
</div>
<div id="explorando-dados-graficamente-ggplot2" class="section level2">
<h2><span class="header-section-number">1.5</span> Explorando dados graficamente: ggplot2</h2>
<p>A exploração gráfica de dados é crucial para entendermos sua distribuição e decidirmos que teste estatístico usar. Na próxima seção falaremos um pouco mais sobre distribuição de dados, mas aqui aprenderemos como visualizar graficamente nossos dados com um pacote chamado <code>ggplot2</code>.</p>
<p>Podemos dizer que gráficos nos ajudam a ver a relação entre uma variável <strong>resposta</strong> e uma variável <strong>explicativa</strong>. Se você quiser usar uma linguagem com menos relação de causalidade, pode chamar essas variáveis de variável resposta e <strong>variável independente</strong> (voltaremos a esses termos na seção 2).</p>
<p>Pense em como você tentaria demonstrar graficamente as respostas às seguintes perguntas:</p>
<pre><code>- qual a relação entre altura e tamanho do pé?

- qual a relação entre gênero e altura?

- qual a relação entre a instituição e a escolha por bolacha/biscoito?</code></pre>
<p>Em todos esses exemplos, temos a relação entre uma variável X que (suspeitamos) <em>explique</em> uma variável Y. Esperamos que a altura explique o tamanho do pé (quanto mais alto, maior o pé), que gênero explique altura (gênero masculino prevê maiores alturas) e que a instituição explique preferências por usar as palavras bolacha ou biscoito (biscoito mais comum na UFRN, bolacha mais comum na Unicamp).</p>
<p>O pacote de visualização gráfica de dados <code>ggplot2</code> tem esse nome porque se basea no livro <em>Grammar of Graphics</em>, de Leland Wilkinson. A ideia principal é criar gráficos como se eles fossem frases de uma língua, em que cada elemento do gráfico é uma palavra. Ou seja, trabalha-se com o conceito de <strong>gramática de gráficos</strong> (por isso o <code>gg</code> em <code>ggplot2</code>).</p>
<p>Uma outra maneira de entender a função <code>ggplot</code> e sua sintaxe é vê-la como a tela em branco de um quadro: começamos pintando os aspectos ao fundo, mais estruturais do quadro, e depois vamos adicionando camadas (agradeço à professora Livia Oushiro por ter me apresentado essa analogia!).</p>
<p>Os gráficos criados com esta ferramenta são, em geral, mais bonitos do que os gráficos tradicionais do <code>R</code> ou de outras ferramentas similares. Uma vez que você entenda sua sintaxe básica, é muito fácil editar o gráfico em termos de cores, contornos, variáveis etc.</p>
<div id="ggplot-sintaxe-básica" class="section level3">
<h3><span class="header-section-number">1.5.1</span> ggplot: Sintaxe Básica</h3>
<p>Para fazer um gráfico usando o <code>ggplot2</code>, primeiro precisamos que nossos dados estejam em um <em>dataframe</em>, pois não é possível trabalhar diretamente com dados de um vetor. Esse é o caso do conjunto de dados com que estamos trabalhando aqui.</p>
<blockquote>
<p><strong>DICA!</strong> Ao construir um <em>dataframe</em>, evite usar acentuação, caracteres especiais ou espaços nos nomes de suas variáveis. Isso evitará que você tenha problemas posteriormente com problemas de codificação.</p>
</blockquote>
<p>A sintaxe básica do ggplot se dá através do comando abaixo, que define duas características importantes de um gráfico:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## sintaxe básica

<span class="kw">ggplot</span>(dados, <span class="kw">aes</span>(<span class="dt">x =</span> variável_explicativa, <span class="dt">y =</span> variável_resposta))</code></pre></div>
<ul>
<li><strong>dados</strong>: o conjunto de dados a ser utilizado para trabalhar a visualização</li>
<li><strong>aes</strong> ou <strong>estética</strong> (aesthetics): as variáveis selecionadas para plotagem, agrupamento, coloração etc.</li>
</ul>
<p>Todo tipo de gráfico que vamos construir parte desse código, então sua primeira tarefa é sempre pensar qual é sua variável explicativa e qual é sua variável resposta. Vejamos algumas opções de visualização para as questões colocadas anteriormente.</p>
</div>
<div id="gráficos-de-dispersão" class="section level3">
<h3><span class="header-section-number">1.5.2</span> Gráficos de dispersão</h3>
<p>Considere a seguinte pergunta:</p>
<ul>
<li>Será que pessoas mais altas têm pés maiores?</li>
</ul>
<p>Ao colocarmos essa pergunta, estamos questionando se o tamanho de uma pessoa explica o tamanho de pé que ela tem. Temos, então, nossa variável explicativa (altura) e a variável resposta (tamanho do pé), e as duas são variáveis numéricas. Uma maneira de visualizar a relação entre duas variáveis de natureza numérica é através de um gráfico de dispersão, que indica cada observação com um ponto na coordenada em que os valores das duas variáveis se cruzam. Começamos preenchendo a sintaxe básica do <code>ggplot</code> com nossas variáveis.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">

## criando a estrutura básica do nosso gráfico

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> altura, <span class="dt">y =</span> tamanho.pe))</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot1-1.png" width="480" /></p>
<p>Se você tentou rodar o código acima, recebeu uma mensagem de erro. O erro ocorreu porque é preciso informar a <strong>geometria</strong> do gráfico, ou seja, o modo como queremos dispôr nossa informação: colunas, linhas, pontos etc.</p>
<p>A geometria de um gráfico de dispersão (adequado para duas variáveis numéricas) é <code>geom_point</code>. Inserimos um sinal <code>+</code> ao fim da primeira linha para indicar que continuamos “pintando” nosso gráfico na linha seguinte.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## adicionando a camada de geometria, indicando geometria de pontos

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> altura, <span class="dt">y =</span> tamanho.pe))+
<span class="st">  </span><span class="kw">geom_point</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot2-1.png" width="480" /></p>
<p>Agora sim temos um gráfico de dispersão que mostra que, a medida que as pessoas ficam mais altas, o tamanho de seus pés aumenta.</p>
<p>Devemos lembrar que <strong>dados, estética e geometria são três camadas obrigatórias de todo gráfico</strong>. Se você deixar de fora um desses elementos, seu código retornará uma mensagem de erro.</p>
<p>Continuemos editando eesse gráfico para deixá-lo mais informatimo. É possível que haja sobreposição dos pontos, e portanto seria interessante mexer nas características dos pontos para adicionar transparência (<code>alpha</code>) e para modificar seu tamanho (<code>size</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## modificando os elementos introduzidos pela camada geometria

## o valor de alpha vai de 0 (completamente transparente) a 1 (completamente opaco)

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> altura, <span class="dt">y =</span> tamanho.pe))+
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">3</span>, <span class="dt">alpha =</span> <span class="fl">0.3</span>) </code></pre></div>
<p><img src="mlm_files/figure-html/ggplot3-1.png" width="480" /></p>
<p>De fato, havia sobreposição. Há mais de uma pessoa com 160cm que calça 36.</p>
<p>Ainda é possível adicionar um novo agrupamento de dados a partir dos elementos da geometria. Suponha que eu queira identificar, no elementro de geometria, o gênero do indivíduos. Preciso fazer isso indicando a <em>estética</em> dessa geometria a partir da variável <code>genero</code>. Afinal, como vimos, a estética é responsável por informar as variáveis que vamos usar para definir cores, plotagem, agrupamento etc.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## agrupando dados por nova variável na camada de geometria por meio de cor

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> altura, <span class="dt">y =</span> tamanho.pe))+
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">3</span>, <span class="dt">alpha =</span> <span class="fl">0.3</span>, <span class="kw">aes</span>(<span class="dt">color =</span> genero))</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot4-1.png" width="480" /></p>
<p>Se prefere não usar cores para isso, pode usar o formato dos elementos introduzidos na geometria.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## agrupando dados por nova variável na camada de geometria por meio de formato

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> altura, <span class="dt">y =</span> tamanho.pe))+
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">3</span>, <span class="dt">alpha =</span> <span class="fl">0.3</span>, <span class="kw">aes</span>(<span class="dt">shape =</span> genero))</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot4.1-1.png" width="480" /></p>
<div id="tarefa-gráficos-de-dispersão" class="section level4">
<h4><span class="header-section-number">1.5.2.1</span> Tarefa: gráficos de dispersão</h4>
<ul>
<li>Leia o código abaixo e tente adivinhar que tipo de gráfico ele construiria. Depois rode o código e veja se você acertou.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> altura, <span class="dt">y =</span> peso))+
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">3</span>, <span class="dt">alpha =</span> <span class="fl">0.6</span>, <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>)</code></pre></div>
<ul>
<li>Tente escrever o código que produz o gráfico abaixo.</li>
</ul>
<p><img src="mlm_files/figure-html/tarefadisp2-1.png" width="480" /></p>
</div>
</div>
<div id="boxplots" class="section level3">
<h3><span class="header-section-number">1.5.3</span> Boxplots</h3>
<p>Até o momento, vimos como mostrar graficamente a relação entre duas variáveis numéricas. No entanto, a pergunta abaixo indica que queremos ver a relação entre uma variável explicativa categórica (gênero) e uma variável resposta numérica (altura).</p>
<ul>
<li>Será que o gênero de uma pessoa prevê sua altura?</li>
</ul>
<p>Para ver como uma variável categórica influencia a distribuição das observações de uma variável numérica, podemos usar um tipo de gráfico chamado boxplot. O boxplot, portanto, é a geometria do nosso gráfico.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Criando um boxplot

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> genero, <span class="dt">y =</span> altura))+
<span class="st">  </span><span class="kw">geom_boxplot</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot.box-1.png" width="480" /></p>
<p>Aqui assumimos que você já conhece e sabe ler um <em>boxplot</em>, por isso não explicaremos o que ele indica. Se você não souber, procure informações em livros ou na internet<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. Não vamos usar muito boxplot no tutorial, mas é bom que você o conheça.</p>
<p>Para editar a aparência do boxplot, podemos usar os comandos que vimos anteriormente, mas há algumas diferenças. Rodando o código abaixo, você verá que <code>color</code>, <code>alpha</code> e <code>shape</code> alteram a geometria do gráfico, que nesse caso é a <em>forma</em> do boxplot, mas não o seu preenchimento.</p>
<blockquote>
<p><strong>DICA!</strong> É possível escolher as cores que você quer para um gráfico selecionando seu código hexadecimal. Abaixo usamos o código <code>#8bd5c4</code>, que corresponde a um tom de verde.</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## personalizando o gráfico: note que é possível informar a cor por sua notação RGB

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> genero, <span class="dt">y =</span> altura))+
<span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="dt">alpha =</span> <span class="fl">0.4</span>, <span class="dt">size =</span> <span class="dv">4</span>, <span class="dt">color =</span> <span class="st">&quot;#8bd5c4&quot;</span>)</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot2.box-1.png" width="480" /></p>
<p>O gráfico que acabamos de fazer é meio esquisito porque, na verdade, nós não queremos mudar a cor do boxplot, mas sim o seu <em>preenchimento</em>. Para fazermos isso, indicamos a cor que queremos com <code>fill</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## personalizando o gráfico: note que é possível informar a cor por sua notação RGB

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> genero, <span class="dt">y =</span> altura))+
<span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="dt">fill =</span> <span class="st">&quot;#8bd5c4&quot;</span>)</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot2.1.box-1.png" width="480" /></p>
<p>E se quisermos ver as diferenças de gênero/altura por instituições? Nesse caso, é possível inserir informação sobre a variável <code>instituicao</code> na estética da geometria do gráfico. Note que, mais uma vez, indicamos <code>fill</code>, e não <code>color</code>, pois nesse caso trata-se do preenchimento da geometria.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## indicando preenchimento da geometria pela variável genero

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> genero, <span class="dt">y =</span> altura))+
<span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="kw">aes</span>(<span class="dt">fill =</span> instituicao))</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot3.box-1.png" width="480" /></p>
<p>Outra maneira de fazer a distinção por gênero seria adicionar uma quarta camada no gráfico, chamada <strong>facet</strong>. Essa camada é útil para dividir informações do gráfico por uma variável e facilitar a comparação.</p>
<p>Note que o gráfico que fizemos acima permite a comparação de altura para homens ou mulheres entre as instituições, mas é difícil visualizar se as diferenças entre os dois gêneros varia de instituição para instituição.</p>
<p>Adicionando uma quarta camada, chamada <strong><em>facet</em></strong>, o que foi indicado nas linhas anteriores do gráfico se dividirá pela variável indicada para criar os grupos (ou facetas).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Boxplot mostrando altura para cada gênero; um painel por instituição

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> genero, <span class="dt">y =</span> altura))+
<span class="st">  </span><span class="kw">geom_boxplot</span>()+
<span class="st">  </span><span class="kw">facet_wrap</span>(~<span class="st"> </span>instituicao)</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot4.box-1.png" width="480" /></p>
<p>É possível cruzar variáveis categóricas em <em>facet</em> para criar mais grupos. Abaixo, queremos ver a altura de homens e mulheres por instituição, também fazendo uma distinção entre aqueles que praticam esportes e que não praticam. Esse cruzamento de variáveis não é muito informativo, não temos nenhuma hipótese sobre porque a distribuição de altura mudaria em cada um desse grupos, mas mostramos essa possibilidade aqui apenas para vermos como <em>facet</em> funciona.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## criar gráficos nos 6 agrupamentos do cruzamento de instituição e esporte

## determinar número de colunas = 2 (&#39;ncol = 2&#39;) nos painéis do facet para facilitar 
## comparação (o default seria 3)

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> genero, <span class="dt">y =</span> altura))+
<span class="st">  </span><span class="kw">geom_boxplot</span>()+
<span class="st">  </span><span class="kw">facet_wrap</span>(~<span class="st"> </span>instituicao +<span class="st"> </span>esporte, <span class="dt">ncol =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot5.box-1.png" width="480" /></p>
<p>Também é possível usar facet para outros gráficos, como os gráficos de dispersão que fizemos anteriormente.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Criando gráficos de dispersão com painéis diferentes para cada gênero

<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> altura, <span class="dt">y =</span> tamanho.pe))+
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">3</span>, <span class="dt">alpha =</span> <span class="fl">0.3</span>)+
<span class="st">  </span><span class="kw">facet_wrap</span>(~<span class="st"> </span>genero)</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot4.2-1.png" width="480" /></p>
<p>Se é melhor mostrar variáveis por meio de diferentes cores em um mesmo gráfico ou se é melhor separar os gráficos por painéis diferentes usando <em>facet</em> é uma decisão que cabe a você!</p>
<blockquote>
<p><strong>ATENÇÃO!</strong> Quem desenha o gráfico é o <code>R</code>, mas quem pensa é você! Pondere bem qual é a melhor maneira de apresentar suas informações graficamente e depois escreva o seu código.</p>
</blockquote>
<div id="tarefa-boxplot" class="section level4">
<h4><span class="header-section-number">1.5.3.1</span> Tarefa: boxplot</h4>
<ul>
<li>Leia o código abaixo e tente adivinhar que tipo de gráfico ele construiria. Depois rode o código e veja se você acertou.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">ggplot</span>(linguistas.edit, <span class="kw">aes</span>(<span class="dt">x =</span> status, <span class="dt">y =</span> idade))+
<span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="kw">aes</span>(<span class="dt">fill =</span> instituicao))</code></pre></div>
<ul>
<li>Tente escrever o código que reproduz o gráfico abaixo (para a cor, use “lightblue”).</li>
</ul>
<p><img src="mlm_files/figure-html/tarefabox2-1.png" width="480" /></p>
</div>
</div>
<div id="gráfico-de-barras" class="section level3">
<h3><span class="header-section-number">1.5.4</span> Gráfico de barras</h3>
<p>Em algumas situações, nossa variável resposta também tem natureza categórica. É o que observamos na seguinte pergunta:</p>
<ul>
<li>Será que a instituição em que a pessoa estuda ou trabalha prevê se ela chamaria um pacote de Bono de biscoito ou bolacha?</li>
</ul>
<p>No caso de duas variáveis categóricas (dialeto e instituição), usa-se um <strong>gráfico de barras</strong> para indicar a quantidade ou porcentagem de uma variável em função de outra. Os códigos base do <code>R</code> para fazer gráficos de barra são um pouco complicados, e mesmo o <code>ggplot2</code> não tem uma sintaxe amigável com a geometria <code>geom_bar</code>. No entanto, uma maneira simples de fazer um gráfico de barras usando o <code>ggplot2</code> é combinar o uso desse pacote com o <code>dplyr</code>.</p>
<p>A combinação entre esses dois pacotes ocorre quando processamos e agrupamos os dados que queremos usando o <code>dplyr</code> e usamos o seu resultado para criar um gráfico. Na pergunta que nos colocamos, queremos saber o número de pessoas que fala bolacha ou biscoito em cada instituição. Comecemos por um passo simples: criar uma tabela com o número de ocorrências de cada instituição. Já sabemos fazer isso.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Tabela indicando frequência absoluta por instituição

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;   instituicao quantidade</span>
<span class="co">#&gt;   &lt;fct&gt;            &lt;int&gt;</span>
<span class="co">#&gt; 1 UFMG                28</span>
<span class="co">#&gt; 2 UFRN                17</span>
<span class="co">#&gt; 3 Unicamp             16</span></code></pre></div>
<p>Para que essa tabela vire um gráfico, basta que acrescentemos o código do ggplot indicando que queremos nossa variável explicativa no eixo x (a instituição) e o número de ocorrências no eixo y. No lugar onde costumamos informar o conjunto de dados, inserimos um ponto <code>.</code> para indicar que o input vem do código anterior.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Gráfico indicando frequência absoluta por instituição

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(<span class="dt">x =</span> instituicao, <span class="dt">y =</span> quantidade))</code></pre></div>
<p><img src="mlm_files/figure-html/ggplotcol.2-1.png" width="480" /></p>
<p>A essa altura você já deve ter percebido que o código acima não gerou um gráfico de barras porque esquecemos de indicar sua geometria. Fazemos isso agora com a geometria <code>geom_col</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Gráfico de barra (coluna) indicando frequência absoluta por instituição

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(<span class="dt">x =</span> instituicao, <span class="dt">y =</span> quantidade))+
<span class="st">  </span><span class="kw">geom_col</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/ggplotcol.3-1.png" width="480" /></p>
<p>O gráfico está feito, mas não mostra a proporção de quem fala bolacha ou biscoito em cada instituição. Para isso, vamos ter que pedir que nossa tabela faça o agrupamento cruzando as informações de <code>instituicao</code> e dialeto <code>dialeto</code>. Fazemos isso alterando a segunda linha do código.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Gráfico de barra (coluna) indicando frequência absoluta por instituição x dialeto

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao, dialeto)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(<span class="dt">x =</span> instituicao, <span class="dt">y =</span> quantidade))+
<span class="st">  </span><span class="kw">geom_col</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/ggplotcol.4-1.png" width="480" /></p>
<p>Continuamos sem ver a distribuição entre os níveis da variável <code>dialeto</code>. Isso ocorre porque não indicamos, na estética, <em>como</em> queremos ver essa variável representada. Digamos que queremos vê-la no preenchimento das barras. Já sabemos que a função <code>fill =</code> faz isso. Inserimos essa informação na geometria do gráfico.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Gráfico de barra (coluna) indicando frequência absoluta por
## instituição x dialeto com fill

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao, dialeto)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(<span class="dt">x =</span> instituicao, <span class="dt">y =</span> quantidade, <span class="dt">fill =</span> dialeto))+
<span class="st">  </span><span class="kw">geom_col</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/ggplotcol.5-1.png" width="480" /></p>
<p>Podemos ainda colocar as barras lado a lado (o <em>default</em> do ggplot é empilhar as barras).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Gráfico de barra (coluna) indicando frequência absoluta por
## instituição x dialeto com fill

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao, dialeto)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(<span class="dt">x =</span> instituicao, <span class="dt">y =</span> quantidade, <span class="dt">fill =</span> dialeto))+
<span class="st">  </span><span class="kw">geom_col</span>(<span class="dt">position =</span> <span class="st">&quot;dodge&quot;</span>)</code></pre></div>
<p><img src="mlm_files/figure-html/ggplotcol.6-1.png" width="480" /></p>
<p>Se quisermos um gráfico indicando o número de ocorrências, já temos o resultado. No entanto, às vezes queremos que a indicação venha em frequência relativa ou porcentagem para normalizar o fato de termos muito mais dados em uma condição (UFMG, no caso) do que em outras.</p>
<p>Para isso, usamos a função <code>mutate()</code> no dplyr para gerar um novo valor através da tabela que construímos antes. Nós vamos chamar esse valor de <code>frequencia</code>, e ele será igual o valor de <code>quantidade</code> dividido pela soma total de todos os valores de <code>quantidade</code> (esse é o cálculo que fazemos para extrair frequência relativa).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Gráfico de barra (coluna) indicando frequência absoluta por
## instituição x dialeto com fill

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao, dialeto)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">frequencia =</span> quantidade/<span class="kw">sum</span>(quantidade))
<span class="co">#&gt; # A tibble: 6 x 4</span>
<span class="co">#&gt; # Groups:   instituicao [3]</span>
<span class="co">#&gt;   instituicao dialeto  quantidade frequencia</span>
<span class="co">#&gt;   &lt;fct&gt;       &lt;fct&gt;         &lt;int&gt;      &lt;dbl&gt;</span>
<span class="co">#&gt; 1 UFMG        Biscoito         20      0.714</span>
<span class="co">#&gt; 2 UFMG        Bolacha           8      0.286</span>
<span class="co">#&gt; 3 UFRN        Biscoito         14      0.824</span>
<span class="co">#&gt; 4 UFRN        Bolacha           3      0.176</span>
<span class="co">#&gt; 5 Unicamp     Biscoito          3      0.188</span>
<span class="co">#&gt; 6 Unicamp     Bolacha          13      0.812</span></code></pre></div>
<p>A tabela nos indica que 71.4% dos linguistas da UFMG falam biscoito e 28.6% falam bolacha. Isso é muito mais informativo que apenas indicar o número de ocorrências.</p>
<p>Para fazer um gráfico de barras, é só continuar com o código inserindo a sintaxe do ggplot.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Gráfico de barra (coluna) indicando frequência relativa por
## instituição x dialeto com fill

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao, dialeto)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">frequencia =</span> quantidade/<span class="kw">sum</span>(quantidade))%&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(<span class="dt">x =</span> instituicao, <span class="dt">y =</span> frequencia, <span class="dt">fill =</span> dialeto))+
<span class="st">  </span><span class="kw">geom_col</span>(<span class="dt">position =</span> <span class="st">&quot;dodge&quot;</span>)</code></pre></div>
<p><img src="mlm_files/figure-html/ggplotcol.8-1.png" width="480" /></p>
<p>Usando a frequência relativa, percebemos que não há muita diferença entre UFMG e UFRN. Se quisermos que nosso eixo y indique a <strong>porcentagem</strong> dos dados, é só acrescentar essa informação no gráfico.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Gráfico de barra (coluna) indicando porcentagem por 
## instituição x dialeto com fill

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao, dialeto)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">frequencia =</span> quantidade/<span class="kw">sum</span>(quantidade))%&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(<span class="dt">x =</span> instituicao, <span class="dt">y =</span> frequencia, <span class="dt">fill =</span> dialeto))+
<span class="st">  </span><span class="kw">geom_col</span>(<span class="dt">position =</span> <span class="st">&quot;dodge&quot;</span>)+
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels=</span>scales::percent)</code></pre></div>
<p><img src="mlm_files/figure-html/ggplotcol.9-1.png" width="480" /></p>
<p>Se parece muita coisa para lembrar, não se preocupe! Uma vez que você saiba o que quer fazer e conheça o básico de <code>R</code>, saberá buscar exemplos de códigos na internet (ou mesmo neste tutorial) e ajustar o que precisa.</p>
<blockquote>
<p><strong>DICA!</strong> Pense que aprender uma linguagem de programação é como aprender uma língua estrangeira: quanto mais você usar, mais fácil fica de lembrar as palavras e a sintaxe da sentença que você quer construir. No entanto, quem está no nível básico também consegue fazer muita coisa consultado livros e dicionários. Não tenha receio de consultar códigos prontos enquanto não consegue escrevê-los do zero!</p>
</blockquote>
<div id="tarefa-gráfico-de-barras" class="section level4">
<h4><span class="header-section-number">1.5.4.1</span> Tarefa: gráfico de barras</h4>
<ul>
<li>Leia o código abaixo e tente adivinhar que tipo de gráfico ele construiria. Depois rode o código e veja se você acertou.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao, status, deslocamento)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">frequencia =</span> quantidade/<span class="kw">sum</span>(quantidade))%&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(<span class="dt">x =</span> status, <span class="dt">y =</span> frequencia, <span class="dt">fill =</span> deslocamento))+
<span class="st">  </span><span class="kw">geom_col</span>()+
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels=</span>scales::percent)+
<span class="st">  </span><span class="kw">facet_wrap</span>(~instituicao)</code></pre></div>
<blockquote>
<p><strong>DICA!</strong> Tenha atenção quando for usar <code>facet_wrap</code> e <code>group_by</code> para um gráfico. Quando for construir a tabela no <code>group_by</code>, informe primeiro a variável que vai no <code>facet_wrap</code>, depois a que vai no eixo x e, por fim, a que vai no preenchimento de cores das barras.</p>
</blockquote>
<ul>
<li>Leia o código abaixo e tente descobrir porque ele não retorna o que descreve sua descrição. Arrume o código.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Gráfico de barra mostrando a proporção (em %) de pessoas que faz atividade física 
## em cada uma das instituições

linguistas.edit%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(instituicao, esporte)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">quantidade =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">frequencia =</span> quantidade/<span class="kw">sum</span>(quantidade))%&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(<span class="dt">x =</span> instituicao, <span class="dt">y =</span> frequencia))+
<span class="st">  </span><span class="kw">geom_col</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/ggplot.bar7-1.png" width="480" /></p>
</div>
</div>
<div id="não-pare-por-aqui" class="section level3">
<h3><span class="header-section-number">1.5.5</span> Não pare por aqui!</h3>
<p>Vimos apenas algumas das possibilidades de customização de gráficos com o ggplot. Você pode alterar as cores, temas e fontes do gráfico, colocar legendas, barras de erros e outras informações que desejar. A internet e a grande comunidade de R Users são suas amigas nessa hora!</p>
</div>
</div>
<div id="prática" class="section level2">
<h2><span class="header-section-number">1.6</span> Prática</h2>
<p>O conjunto de dados da planilha <code>pronome.csv</code> é um subconjunto dos dados do experimento descrito em Godoy et al. (2018) (voltaremos a esse estudo na Seção 5).</p>
<p>Uma das hipóteses desse estudo era a de que a interpretação do pronome ambíguo das sentenças (1) e (2) seria influenciada pelo aspecto perfectivo (“passou”) ou imperfectivo (“estava passando”) do verbo da sentença anterior. A probabilidade de escolher o referente no papel temático de alvo (e.g. Rubens) seria maior em (1) que em (2).</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>Augusto passou a bola para Rubens. Ele…</li>
<li>Augusto estava passando a bola para Rubens. Ele…</li>
</ol>
</blockquote>
<p>Para testar essa hipótese, os autores criaram sentenças semelhantes a essas e pediram para os participantes criarem continuações. Depois, analisaram as respostas para identificar se a interpretação do pronome retomava a fonte (como Augusto) ou o alvo (Rubens) e anotaram essas respostas numa planilha que você pode acessar importando o conjunto de dados <code>pronomes.csv</code>.</p>
<p>O conjunto de dados contém 6 colunas:</p>
<blockquote>
<p><code>participante</code>, com identificação dos participantes da pesquisa;</p>
</blockquote>
<blockquote>
<p><code>item</code>, com identificação de 16 histórias utilizadas como itens experimentais;</p>
</blockquote>
<blockquote>
<p><code>frase</code>, com as frases utilizadas no experimento;</p>
</blockquote>
<blockquote>
<p><code>aspecto</code>, com identificação das condições de aspecto verbal: perfectivo (<code>perfective</code>) e imperfectivo (<code>imperfective</code>);</p>
</blockquote>
<blockquote>
<p><code>classe</code>, uma condição experimental que entenderemos na Seção 5;</p>
</blockquote>
<blockquote>
<p><code>interpretacao</code>: interpretação do pronome tal qual anotado pelos pesquisadores, e que indica interpretação de fonte (<code>fonte</code>), alvo (<code>alvo</code>) ou ambígua (<code>ambiguo</code>).</p>
</blockquote>
<p>Para ver se a hipótese dos autores foi corroborada pelos dados, você deverá:</p>
<ul>
<li>Importar a planilha;</li>
<li>Inspecionar o conjunto de dados;</li>
<li>Filtrar os dados da coluna <code>interpretacao</code> para selecionar apenas os dados com os valores <code>fonte</code> ou <code>alvo</code>;</li>
<li>Extrair a frequência absoluta e relativa de fonte/alvo por aspecto;</li>
<li>Fazer um gráfico indicando a porcentagem de fonte ou alvo por aspecto.</li>
</ul>
<p></p>
<p></p>
<p></p>
</div>
</div>
<div id="modelos-lineares" class="section level1">
<h1><span class="header-section-number">2</span> Modelos Lineares</h1>
<p>Modelos lineares mistos são, por definição, modelos lineares. Por isso, é importante entendermos primeiro o que é um modelo linear. Nesta seção, vamos apresentar alguns conceitos básicos.</p>
<p>Enquanto você acompanha a parte introdutória do tutorial, baixe os novos pacotes que serão usados para as atividades e carregue os pacotes que serão usados:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## instalar pacote novo para a seção

<span class="kw">install.packages</span>(<span class="st">&quot;yarrr&quot;</span>)

## carregar pacotes

<span class="kw">library</span>(ggplot2)
<span class="kw">library</span>(dplyr)</code></pre></div>
<div id="modelos-lineares-sintaxe-em-r-e-conceitos-básicos" class="section level2">
<h2><span class="header-section-number">2.1</span> Modelos lineares: sintaxe em R e conceitos básicos</h2>
<p>Para demonstrar o que é um modelo linear, seguiremos uma adaptação do tutorial de Bodo Winter (2013), usando o mesmo conjunto de dados e mudando um pouco a ordem de apresentação dos argumentos.</p>
<p>Começaremos criando o mesmo conjunto de dados que Winter cria para responder a seguinte pergunta: a idade de uma pessoa prevê o seu pitch?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Criar conjunto de dados de Winter (2013)

## criando vetor idade
idade =<span class="st"> </span><span class="kw">c</span>(<span class="dv">14</span>,<span class="dv">23</span>,<span class="dv">35</span>,<span class="dv">48</span>,<span class="dv">52</span>,<span class="dv">67</span>)

##criando vetor pitch
pitch =<span class="st"> </span><span class="kw">c</span>(<span class="dv">252</span>,<span class="dv">244</span>,<span class="dv">240</span>,<span class="dv">233</span>,<span class="dv">212</span>,<span class="dv">204</span>)

## combinando os dois vetores em um dataframe
my.df =<span class="st"> </span><span class="kw">data.frame</span>(idade,pitch)

## vendo o dataframe

<span class="kw">head</span>(my.df)
<span class="co">#&gt;   idade pitch</span>
<span class="co">#&gt; 1    14   252</span>
<span class="co">#&gt; 2    23   244</span>
<span class="co">#&gt; 3    35   240</span>
<span class="co">#&gt; 4    48   233</span>
<span class="co">#&gt; 5    52   212</span>
<span class="co">#&gt; 6    67   204</span></code></pre></div>
<p>Ao olharmos a o conjunto de dados que criamos, percebemos que as pessoas mais novas parecem ter um pitch mais alto. Na verdade, podemos representar cada indivíduo em um gráfico como na <strong>Figura 2.1</strong>, e isso nos mostrará que (a) parece haver uma relação entre idade e pitch; (b) essa relação pode ser modelada por uma linha reta.</p>
<div align="center">
<div class="figure"><span id="fig:unnamed-chunk-1"></span>
<img src="mlm_files/figure-html/unnamed-chunk-1-1.png" alt="Relação entre pitch e idade" width="480" />
<p class="caption">
Figure 2.1: Relação entre pitch e idade
</p>
</div>
</div>
<p><br></p>
<p>Ao ver o gráfico acima, é possível nos perguntarmos se <em>pitch muda em função de idade</em>.</p>
<p>Um modelo linear é uma maneira matemática de avaliar se pitch e idade se relacionam de alguma maneira. Para isso, vamos expressar em uma fórmula simples a relação entre as duas variáveis que estamos estudando.</p>
<p><br></p>
<div align="center">
<blockquote>
<p>pitch ~ idade</p>
</blockquote>
</div>
<p><br></p>
<p>A fórmula acima pode ser lida como <em>pitch em função de idade</em>. Você já deve ter visto esses termos sendo chamados de <em>variável dependente</em> (o pitch, aquilo que medimos) e <em>variável independente</em> (a idade, aquilo que acreditamos que terá um efeito ou que se correlaciona de alguma maneira com a variável dependente). Também é possível chamar essas duas variáveis de <strong>variável resposta</strong> e <strong>variável preditora</strong>, respectivamente, em uma relação mais causal. Aqui, chamaremos a variável independente de <strong>efeito fixo</strong>, por motivos que ficarão claros mais adiante.</p>
<p>É possível que haja uma relação entre pitch e idade, mas as coisas não são tão determinísticas assim. O pitch pode ser influenciado por outros aspectos, e a mesma pessoa pode ver seu pitch mudar a depender de fatores como estado emocional, disposição, doenças que afetem as vias respiratórias etc. Nossa fórmula é então reescrita com a adição de um termo que capte esses fatores aleatórios. Na formula abaixo, <span class="math inline">\(\epsilon\)</span> representa todo o ruído que afeta pitch e que não foi controlado no experimento.</p>
<p><br></p>
<div align="center">
<blockquote>
<p>pitch ~ idade + <span class="math inline">\(\epsilon\)</span></p>
</blockquote>
</div>
<p>Para criar um modelo linear no R, usamos a função <code>lm()</code> e escrevemos a equação desejada como seu argumento.</p>
<p>Abaixo, criamos o objeto <code>modelo.idade</code>, que corresponde a um modelo linear que toma pitch em função de idade a partir do conjunto de dados <code>my.df</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Criando um modelo linear de pitch em função de idade

modelo.idade =<span class="st"> </span><span class="kw">lm</span>(pitch ~<span class="st"> </span>idade, my.df)</code></pre></div>
<p>Podemos usar a função <code>names()</code> para ver os dados contidos dentro de <code>modelo.idade</code>. Na sequência, vemos o conteúdo de <code>fitted.values</code> e <code>residuals</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## ver os nomes dos objetos contidos no objeto modelo.idade

<span class="kw">names</span>(modelo.idade)
<span class="co">#&gt;  [1] &quot;coefficients&quot;  &quot;residuals&quot;     &quot;effects&quot;       &quot;rank&quot;         </span>
<span class="co">#&gt;  [5] &quot;fitted.values&quot; &quot;assign&quot;        &quot;qr&quot;            &quot;df.residual&quot;  </span>
<span class="co">#&gt;  [9] &quot;xlevels&quot;       &quot;call&quot;          &quot;terms&quot;         &quot;model&quot;</span>

## ver o que há em fitted.values

modelo.idade$fitted.values
<span class="co">#&gt;        1        2        3        4        5        6 </span>
<span class="co">#&gt; 254.3383 246.1495 235.2310 223.4027 219.7633 206.1152</span>

## ver o que há em residuals

modelo.idade$residuals
<span class="co">#&gt;         1         2         3         4         5         6 </span>
<span class="co">#&gt; -2.338293 -2.149468  4.768965  9.597267 -7.763256 -2.115215</span></code></pre></div>
<p>Os valores de <code>fitted.values</code>, <strong>ou valores ajustados</strong>, são os valores previstos pela reta, e os valores residuais são a diferença entre o valor ajustado e o valor observado. Na <strong>Figura 2.2</strong>, os resíduos são representados pela linha que liga valor observado (pontos pretos) e valor ajustado (pontos brancos).</p>
<div align="center">
<div class="figure"><span id="fig:unnamed-chunk-2"></span>
<img src="mlm_files/figure-html/unnamed-chunk-2-1.png" alt="Resíduos e valores ajustados na relação entre pitch e idade" width="480" />
<p class="caption">
Figure 2.2: Resíduos e valores ajustados na relação entre pitch e idade
</p>
</div>
</div>
<p><br></p>
<p>Para saber o resultado do modelo linear, usamos a função <code>summary()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## buscando o sumário dos valores do modelo linear

<span class="kw">summary</span>(modelo.idade)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = pitch ~ idade, data = my.df)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residuals:</span>
<span class="co">#&gt;      1      2      3      4      5      6 </span>
<span class="co">#&gt; -2.338 -2.149  4.769  9.597 -7.763 -2.115 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">#&gt; (Intercept) 267.0765     6.8522   38.98 2.59e-06 ***</span>
<span class="co">#&gt; idade        -0.9099     0.1569   -5.80  0.00439 ** </span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residual standard error: 6.886 on 4 degrees of freedom</span>
<span class="co">#&gt; Multiple R-squared:  0.8937, Adjusted R-squared:  0.8672 </span>
<span class="co">#&gt; F-statistic: 33.64 on 1 and 4 DF,  p-value: 0.004395</span></code></pre></div>
<p>De início, podemos reconhecer duas informações que já sabemos sobre o modelo:</p>
<ul>
<li><code>call</code>: a fórmula usada no modelo</li>
<li><code>residual</code>: os resíduos do modelo</li>
</ul>
<p>Além disso, há uma seção chamada <code>coefficients</code>, mas deixaremos isso para depois.</p>
<p>Dando sequência, vemos no rodapé uma série de informações do modelo como um todo. O <span class="math inline">\(R^2\)</span> (ou <strong>R ao quadrado</strong>) é uma medida que vai de 0 a 1 indica a variância explicada pelo modelo. O valor de 0.89 indica que nosso modelo é capaz de explicar 89% do que está acontecendo no nosso conjunto de dados. Como temos apenas um efeito fixo em <code>modelo.idade</code>, podemos entender o <span class="math inline">\(R^2\)</span> como indicativo da variância explicada pela idade.</p>
<p>Como Winter (2013) aponta, o que é um valor alto de <span class="math inline">\(R^2\)</span> varia de área para área e depende do problema estudado. Em contextos em que o efeito estudado é muito complexo, é mais comum lidarmos com valores mais baixos.</p>
<p>O <strong>valor ajustado de R</strong> (<em>Adjusted R-squared</em>) é um valor relacionado ao <span class="math inline">\(R^2\)</span>, mas que leva em conta o número de efeitos fixos inseridos no modelo. Porque só há um efeito fixo em <code>modelo.idade</code>, os valores são bem similares, mas o valor ajustado seria menor se o modelo tivesse mais efeitos fixos.</p>
<p>Mais adiante, você encontra o <strong>p-valor</strong> associado ao modelo. Para explicá-lo, recorremos ao que diz Winter (2013) em seu tutorial.</p>
<blockquote>
<p>“Uma maneira de colocar seria dizer que, assumindo que seu modelo não esteja fazendo nada, a probabilidade dos seus dados é muito baixa (porque o p-valor é pequeno nesse caso). Tecnicamente, o p-vaor é uma probabilidade condicional, é a probabilidade sob a condição de que a hipótese nula seja verdadeira.” (Winter, B. 2013, p. 5)</p>
</blockquote>
<p>No caso que estamos avaliando aqui, a hipótese nula é “idade não tem qualquer efeito em pitch”, e uma hipótese alternativa seria “idade tem efeito em pitch”.</p>
<blockquote>
<p>“[O] modelo linear mostra que se essa hipótese [nula] é verdadeira, então nossos dados são muito improváveis. Isso é imterpretado como indicativo de que a hipótese alternativa (…) é mais provável e que, portanto, nosso resultado é estatisticamente significativo.” (Winter, B. 2013, p. 5)</p>
</blockquote>
<p>Não podemos confundir o p-valor do modelo completo com o p-valor dos coeficientes dos efeitos fixos (que costumam ser mais interessantes quando fazemos uma análise com modelos mistos, mas falaremos sobre isso em outro momento).</p>
<p>O valor da estatística-F, bem como seus graus de liberdade, são dados na sequência (não vamos cobrir ANOVA e estatística-F nesse curso). Pare reportar seus resultados, você precisa informar esses dados e escrever algo como…</p>
<blockquote>
<p><em>Ajustamos um modelo linear com pitch como variável dependente e idade como efeito fixo. Esse modelo foi estatisticamente significativo (F(1,4) = 33.64, p &lt;0.01).</em></p>
</blockquote>
<p><br></p>
</div>
<div id="os-coeficientes-do-modelo-linear" class="section level2">
<h2><span class="header-section-number">2.2</span> Os coeficientes do modelo linear</h2>
<p>Quando ajustamos um modelo linear, geralmente estamos mais interessados nos coeficientes dos seus efeitos fixos. Abaixo buscamos novamente o sumário dos resultados para análisar seus coeficientes. Achamos essa informação logo abaixo dos resíduos.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## buscando o sumário dos valores do modelo linear

<span class="kw">summary</span>(modelo.idade)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = pitch ~ idade, data = my.df)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residuals:</span>
<span class="co">#&gt;      1      2      3      4      5      6 </span>
<span class="co">#&gt; -2.338 -2.149  4.769  9.597 -7.763 -2.115 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">#&gt; (Intercept) 267.0765     6.8522   38.98 2.59e-06 ***</span>
<span class="co">#&gt; idade        -0.9099     0.1569   -5.80  0.00439 ** </span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residual standard error: 6.886 on 4 degrees of freedom</span>
<span class="co">#&gt; Multiple R-squared:  0.8937, Adjusted R-squared:  0.8672 </span>
<span class="co">#&gt; F-statistic: 33.64 on 1 and 4 DF,  p-value: 0.004395</span></code></pre></div>
<p>Perceba que são atribuídos coeficientes para duas linhas diferentes: <em>intercept</em> e <em>idade</em>. Comecemos pelo primeiro.</p>
<p>O valor de <strong>intercept</strong> em um modelo linear, será o valor em que a reta ajustada pelo modelo <strong>intercepta</strong> o eixo y quando o valor de x (o efeito fixo) é igual a zero. No caso do modelo ajustado, nosso efeito fixo é <em>idade</em>. O valor estimado para o <em>intercept</em> - ou <strong>intercepto</strong>, como iremos chamá-lo daqui em diante - é de 267.07, o que indica o pitch estimado de uma pessoa aos 0 anos de idade. Dito de outro modo, se voltarmos na Figura 2.1 e continuarmos traçando a reta, ela cruzaria o eixo y no valor de 267.07.</p>
<p>Claro que esse intercepto não faz muito sentido, pois não há como uma pessoa não nascida (i.e., com 0 anos) ter pitch. Cabe a você interpretar quão informativo é o intercepto para o modelo ajustado.</p>
<p>Em todo caso, entender o que é o intercepto nos ajuda a compreender o que significa o valor atribuído ao efeito fixo <em>idade</em>. Vemos que é um valor negativo, de -0.9099. Isso indica que para cada unidade que você “anda” à direita no eixo x, o valor e y recebe um decréscimo de 0.9099: dito de outro modo, para cada unidade de x, a reta tem um <strong>declive</strong> (ou <strong>slope</strong>, em inglês) de -0.9099. Lembremos que nosso eixo x indica idade, e o eixo y indica o valor de pitch em hertz. Para usar o termo em inglês, o <strong>slope</strong> estimado de idade indica que, para cada ano de vida, o modelo prevê uma queda em hertz de 0.9099. Assim, o modelo prevê que uma criança de um ano teria um pitch de 267.07 (o valor do intercepto) <em>menos</em> 0.9099. Podemos escrever da seguinte maneira</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## pessoa com um ano

<span class="fl">267.0765</span> -<span class="st"> </span><span class="fl">0.9099</span>
<span class="co">#&gt; [1] 266.1666</span>

## pessoa com dois anos

<span class="fl">267.0765</span> -<span class="st"> </span>(<span class="fl">0.9099</span>*<span class="dv">2</span>)
<span class="co">#&gt; [1] 265.2567</span>

## pessoa com três anos

<span class="fl">267.0765</span> -<span class="st"> </span>(<span class="fl">0.9099</span>*<span class="dv">3</span>)
<span class="co">#&gt; [1] 264.3468</span>

## pessoa com quatorze anos

<span class="fl">267.0765</span> -<span class="st"> </span>(<span class="fl">0.9099</span>*<span class="dv">14</span>)
<span class="co">#&gt; [1] 254.3379</span>

## buscando os valores ajustados no modelo (primeiro dado corresponde a indivíduo 
## de 14 anos)

modelo.idade$fitted
<span class="co">#&gt;        1        2        3        4        5        6 </span>
<span class="co">#&gt; 254.3383 246.1495 235.2310 223.4027 219.7633 206.1152</span></code></pre></div>
<p>Perceba que o valor de pitch que calculamos para uma pessoa de 14 anos é justamente o valor previsto quando pedimos para ver os valores ajustados!</p>
<p>Agora estamos um pouco mais equipados para entender o que um modelo linar faz. Primeiro, convém mencionar que o valor estimado dos coeficientes é chamdo de <em>beta</em>, frequentemente representado pela letra grega <span class="math inline">\(\beta\)</span>. O coeficiente do intercepto é representado por <span class="math inline">\(\beta_{0}\)</span>.</p>
<p>Um modelo linear ajusta uma reta a um plano cartesiano, e os valores previstos por essa reta são previstos pela equação abaixo:</p>
<p><br></p>
<p><strong>Para regressão com uma variável</strong></p>
<p><span class="math inline">\(y=\beta_{0}+\beta_{1}x_{1}\)</span></p>
<p><br></p>
<p><strong>Para regressão com <span class="math inline">\(n\)</span> variáveis</strong></p>
<p><span class="math inline">\(y=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}+...\beta_{n}x_{n}\)</span></p>
<p><br></p>
<p>Voltaremos a essa equação em outro momento.</p>
<p>Ao analisar os coeficientes do modelo, vemos que o <strong>p-valor associado a <em>idade</em></strong> é igual ao p-valor do modelo como um todo: 0.0043. Isso ocorre porque nosso modelo tem apenas um efeito fixo, e portanto a significância do modelo será equivalente a quão significante é esse efeito fixo. Se nosso modelo tivesse mais um efeito fixo (sexo, por exemplo), haveria um p-valor para o modelo (que indicaria a significância do modelo como um todo) com valor diferente do p-valor de idade (que indica a significância da variável idade em definir os valores de y, isto é, de pitch).</p>
<p>O p-valor de 0.0043 nos indica, portanto, que é muito pouco provável a hipótese nula de que <em>idade</em> não tem um efeito sobre o pitch de uma pessoa.</p>
</div>
<div id="modelos-lineares-com-efeitos-fixos-categóricos" class="section level2">
<h2><span class="header-section-number">2.3</span> Modelos lineares com efeitos fixos categóricos</h2>
<p>Até agora, vimos apenas casos em que o efeito fixo é uma variável numérica, mas frequentemente lidamos com variáveis categóricas como gênero, profissão, grau de escolaridade, dialeto etc. A vantagem de trabalhar com modelos lineares é que é possível analisar esses dados da mesma maneira que já vimos anteriormente.</p>
<p>Consideremos um novo conjunto de dados, também criado por Winter (2013). Dessa vez, queremos saber se o pitch de uma pessoa muda em função de seu sexo.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Criando dataframe para testar se pitch ~ sexo

## vetor com dados de pitch
pitch =<span class="st"> </span><span class="kw">c</span>(<span class="dv">233</span>,<span class="dv">204</span>,<span class="dv">242</span>,<span class="dv">130</span>,<span class="dv">112</span>,<span class="dv">142</span>)


## vetor com dados de sexo
sexo =<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="st">&quot;feminino&quot;</span>,<span class="dv">3</span>),<span class="kw">rep</span>(<span class="st">&quot;masculino&quot;</span>,<span class="dv">3</span>))

## combinando os dois vetores em um dataframe
my.df2 =<span class="st"> </span><span class="kw">data.frame</span>(sexo,pitch)

## vendo o dataframe

<span class="kw">head</span>(my.df2)
<span class="co">#&gt;        sexo pitch</span>
<span class="co">#&gt; 1  feminino   233</span>
<span class="co">#&gt; 2  feminino   204</span>
<span class="co">#&gt; 3  feminino   242</span>
<span class="co">#&gt; 4 masculino   130</span>
<span class="co">#&gt; 5 masculino   112</span>
<span class="co">#&gt; 6 masculino   142</span></code></pre></div>
<p><br></p>
<p>Como antes, expressamos a hipótese a ser testada no modelo com a mesma equação:</p>
<p><br></p>
<div align="center">
<blockquote>
<p>pitch ~ sexo + <span class="math inline">\(\epsilon\)</span></p>
</blockquote>
</div>
<p><br></p>
<p>A implementação no R é exatamente a mesma, mas você pode ver que a leitura dos coeficientes vai ser um pouco diferente.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## ajustar o modelo

modelo.sexo =<span class="st"> </span><span class="kw">lm</span>(pitch ~<span class="st"> </span>sexo, my.df2)

## resultados

<span class="kw">summary</span>(modelo.sexo)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = pitch ~ sexo, data = my.df2)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residuals:</span>
<span class="co">#&gt;       1       2       3       4       5       6 </span>
<span class="co">#&gt;   6.667 -22.333  15.667   2.000 -16.000  14.000 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt;               Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">#&gt; (Intercept)     226.33      10.18  22.224 2.43e-05 ***</span>
<span class="co">#&gt; sexomasculino   -98.33      14.40  -6.827  0.00241 ** </span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residual standard error: 17.64 on 4 degrees of freedom</span>
<span class="co">#&gt; Multiple R-squared:  0.921,  Adjusted R-squared:  0.9012 </span>
<span class="co">#&gt; F-statistic: 46.61 on 1 and 4 DF,  p-value: 0.002407</span></code></pre></div>
<p>Já sabemos interpretar os valores de <span class="math inline">\(R^2\)</span> e R ajustado, bem como o p-valor do modelo, que é de 0.002. Não há nada de diferente aqui. Vemos, inclusive, que o p-valor do modelo é igual ao p-valor do coeficiente do efeito fixo, já que, por ser um modelo de apenas um efeito fixo, a significância do modelo e do efeito fixo é a mesma.</p>
<p>No entanto, a linha do efeito fixo na tabela de coeficientes diz apenas <code>sexomasculino</code>. Para onde foi o feminino? O que isso quer dizer? Para responder a essas perguntas, vamos usar o dplyr para extrair as médias de pitch para os indivíduos do sexo masculino e feminino.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## médias de pitch por sexo

my.df2%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(sexo)%&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="kw">mean</span>(pitch))
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   sexo      `mean(pitch)`</span>
<span class="co">#&gt;   &lt;fct&gt;             &lt;dbl&gt;</span>
<span class="co">#&gt; 1 feminino           226.</span>
<span class="co">#&gt; 2 masculino          128</span></code></pre></div>
<p>Se você comparar as médias com os coeficientes, perceberá que o <strong>intercepto</strong> corresponde à média de pitch dos participantes do sexo feminino, o que significa que o modelo tomou o níve <em>feminino</em> como <strong>nível de referência</strong>. É por isso que esse nível não aparece na tabela de coeficientes: ele está “disfarçado” como o intercepto do modelo.</p>
<p>E a linha correspondente a <code>sexomasculino</code>? Vemos que ela tem o valor de <span class="math inline">\(\beta\)</span> igual a -98.33, que em nada se parece com a média dos indivíduos do sexo masculino, que foi de 128hz. No entanto, vemos que esse é exatamente a diferença entre a média masculina e a feminina:</p>
<div align="center">
<blockquote>
<p>média feminina - <span class="math inline">\(\beta\)</span> = média masculina</p>
</blockquote>
<blockquote>
<p>226.33 - 98.33 = 128</p>
</blockquote>
</div>
<p>Para entender melhor o que está acontecendo aqui, vamos dar uma olhada na <strong>Figura 2.3</strong>, que mostra a distribuição dos dados. Lembremos também que um modelo linear tenta ajustar retas que expliquem essa distribuição.</p>
<div align="center">
<div class="figure"><span id="fig:unnamed-chunk-3"></span>
<img src="mlm_files/figure-html/unnamed-chunk-3-1.png" alt="Pitch em função de sexo" width="480" />
<p class="caption">
Figure 2.3: Pitch em função de sexo
</p>
</div>
</div>
<p><br></p>
<p>Vimos que o valor médio do nível feminino foi tomado como intercepto do modelo. Por esse motivo, indicamos no gráfico que o nível feminino tem o valor de x igual a zero. Vemos também, na linha tracejada vermelha, que esse valor é de 226.33.</p>
<p>Para irmos ao valor médio de <em>masculino</em>, que está em x = 1, nossa reta tem que descer 98.33hz: o seu <strong>slope</strong> é de -98.33. Vemos que, quando x = 1, o valor médio de pitch é 128hz, representado pela linha tracejada azul.</p>
<p>Isso não é diferente do que vimos antes: o modelo assume um intercepto para y quando x = 0, e então indica o <strong>slope</strong> que mostra a diferença entre esse intercepto e as outra unidade da variável em x.</p>
<p>Você pode se perguntar o porquê de o feminino - e não o masculino - ter sido tomado como nível de referência. Isso ocorre porque o R organiza os níveis de uma variável categórica em ordem alfabética. Você pode escolher o seu nível de referência (que será o seu intercepto) com a função <code>relevel()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## sobrescrever a coluna sexo com um novo nível de referência

my.df2$sexo =<span class="st"> </span><span class="kw">relevel</span>(my.df2$sexo, <span class="dt">ref =</span> <span class="st">&quot;masculino&quot;</span>)

## ajustar o modelo

modelo.sexo2 =<span class="st"> </span><span class="kw">lm</span>(pitch ~<span class="st"> </span>sexo, my.df2)

## resultados

<span class="kw">summary</span>(modelo.sexo2)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = pitch ~ sexo, data = my.df2)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residuals:</span>
<span class="co">#&gt;       1       2       3       4       5       6 </span>
<span class="co">#&gt;   6.667 -22.333  15.667   2.000 -16.000  14.000 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt;              Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">#&gt; (Intercept)    128.00      10.18  12.568 0.000231 ***</span>
<span class="co">#&gt; sexofeminino    98.33      14.40   6.827 0.002407 ** </span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residual standard error: 17.64 on 4 degrees of freedom</span>
<span class="co">#&gt; Multiple R-squared:  0.921,  Adjusted R-squared:  0.9012 </span>
<span class="co">#&gt; F-statistic: 46.61 on 1 and 4 DF,  p-value: 0.002407</span></code></pre></div>
<p>Acima, usamos essa função para informar que desejamos que <em>masculino</em> seja o nível de referência. Você verá que o resultado no modelo permanecerá quase inalterado, exceto por dois detalhes: o nome da linha do coeficiente de efeito fixo - que agora passar a ser <code>sexofeminino</code> e o sinal do valor do coeficiente estimado, que será positivo. Isso ocorre porque agora a nossa reta precisa subir 98hz, e não descer, como vemos na <strong>Figura 2.4</strong>.</p>
<div align="center">
<div class="figure"><span id="fig:plotsexo2"></span>
<img src="mlm_files/figure-html/plotsexo2-1.png" alt="Pitch em função de sexo, com masculino como intercept" width="480" />
<p class="caption">
Figure 2.4: Pitch em função de sexo, com masculino como intercept
</p>
</div>
</div>
<p><br></p>
<p>Voltemos ao nosso modelo original, em que masculino = 1 e feminino = 0 e vamos olhar novamente a equação do modelo linear.</p>
<p><br></p>
<p><strong>Relembrando cálculo de y na regressão com uma variável</strong></p>
<p><span class="math inline">\(y=\beta_{0}+\beta_{1}x_{1}\)</span></p>
<p><br></p>
<p>Se quisermos calcular o valor de <code>y</code> para masculino (o nosso <span class="math inline">\(x_1\)</span>), podemos substituir essa equação pelo valores obtidos em nosso modelo linear:</p>
<p><span class="math inline">\(\beta_{0}\)</span> = 226.33</p>
<p><span class="math inline">\(\beta_{1}\)</span> = -98.33</p>
<p><span class="math inline">\(x_1\)</span> = 1</p>
<blockquote>
<p>y = 226.33 + (-98.33*1) = 128</p>
</blockquote>
<p>Desse modo, percebemos que aqui também a distribuição de dados está sendo modelada a partir da equação de uma regressão linear.</p>
<p>Entender que o modelo está lendo o o nível de referência como igual a 0 e o nível ao qual está fazendo a comparação como igual a 1 será útil quando discutirmos <strong>contrastes</strong> na seção 4.</p>
</div>
<div id="modelos-lineares-e-outros-testes-estatísticos" class="section level2">
<h2><span class="header-section-number">2.4</span> Modelos lineares e outros testes estatísticos</h2>
<p>Se você conhece um pouco de estatística, deve estar pensando que os problemas que vimos até aqui poderiam ser resolvidos por um teste de correlação (no caso de picth ~ idade) e por um teste-t ou ANOVA (no caso de pitch ~ sexo).</p>
<p>De fato, isso é verdade, e se você fizer essa análise verá que os valores do p-valor para o modelo serão os mesmos. Isso ocorre porque todos esses testes <em>são</em> modelos lineares.</p>
<p>A vantagem do modelo linear e do uso de retas para mostrar diferenças entre dois níveis de uma variável categórica ficará mais clara ao discutirmos as vantagens do modelo linear misto na próxima seção.</p>
</div>
<div id="modelos-lineares-com-mais-de-uma-variável" class="section level2">
<h2><span class="header-section-number">2.5</span> Modelos lineares com mais de uma variável</h2>
<p>Até agora, vimos modelos bastante simples, mas podemos torná-los mais complexo. O pitch de uma pessoa é modelado tanto por seu sexo quanto por sua idade. É possível colocar os dois efeitos no modelo. Adicionalmente, podemos também colocar a língua que ela fala, para testar se esse fator influencia o pitch.</p>
<blockquote>
<p>pitch ~ sexo + idade + língua</p>
</blockquote>
<p>Nesse caso, a análise de resultados será bastante similar. A diferença principal será o p-valor do modelo, que será diferente do p-valor daqueles apresentados para cada um dos efeitos fixos.</p>
<p>Para ilustrar, consideremos o conjunto de dados <code>diamonds</code>, do pacote <code>yarrr</code>. Se você já baixou e carregou esse pacote, esse conjunto de dados já está disponível para inspeção.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## conhecendo o conjunto de dados

<span class="kw">head</span>(diamonds)
<span class="co">#&gt;   weight clarity color value</span>
<span class="co">#&gt; 1   9.35    0.88     4 182.5</span>
<span class="co">#&gt; 2  11.10    1.05     5 191.2</span>
<span class="co">#&gt; 3   8.65    0.85     6 175.7</span>
<span class="co">#&gt; 4  10.43    1.15     5 195.2</span>
<span class="co">#&gt; 5  10.62    0.92     5 181.6</span>
<span class="co">#&gt; 6  12.35    0.44     4 182.9</span>

## conhecendo o conjunto de dados

<span class="kw">str</span>(diamonds)
<span class="co">#&gt; &#39;data.frame&#39;:    150 obs. of  4 variables:</span>
<span class="co">#&gt;  $ weight : num  9.35 11.1 8.65 10.43 10.62 ...</span>
<span class="co">#&gt;  $ clarity: num  0.88 1.05 0.85 1.15 0.92 0.44 1.09 1.43 0.95 1.05 ...</span>
<span class="co">#&gt;  $ color  : num  4 5 6 5 5 4 6 4 6 5 ...</span>
<span class="co">#&gt;  $ value  : num  182 191 176 195 182 ...</span></code></pre></div>
<p>O pacote traz informações sobre 150 diamantes em 4 colunas:</p>
<ul>
<li><p><code>weight</code>: informação sobre o peso do diamante</p></li>
<li><p><code>clarity</code>: informação sobre a claridade do diamante</p></li>
<li><p><code>color</code>: cor do diamente (uma variável categórica)</p></li>
<li><p><code>value</code>: preço de venda do diamante</p></li>
</ul>
<p>Queremos saber se peso e claridade influenciam o preço de venda de diamante (idealmente faríamos alguns gráficos antes das análises, mas teremos tempo para treinar isso nas próximas seções).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## construindo o modelo

modelo.diamonds =<span class="st"> </span><span class="kw">lm</span>(value ~<span class="st"> </span>weight +<span class="st"> </span>clarity, <span class="dt">data =</span> diamonds)

## resultados

<span class="kw">summary</span>(modelo.diamonds)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = value ~ weight + clarity, data = diamonds)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residuals:</span>
<span class="co">#&gt;     Min      1Q  Median      3Q     Max </span>
<span class="co">#&gt; -10.034  -3.802  -0.196   3.207  11.166 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    </span>
<span class="co">#&gt; (Intercept)  145.446      2.795   52.04   &lt;2e-16 ***</span>
<span class="co">#&gt; weight         2.219      0.199   11.15   &lt;2e-16 ***</span>
<span class="co">#&gt; clarity       22.036      2.129   10.35   &lt;2e-16 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Residual standard error: 4.681 on 147 degrees of freedom</span>
<span class="co">#&gt; Multiple R-squared:  0.6334, Adjusted R-squared:  0.6284 </span>
<span class="co">#&gt; F-statistic:   127 on 2 and 147 DF,  p-value: &lt; 2.2e-16</span></code></pre></div>
<p>Em primeiro lugar, vemos que o modelo foi significativo, como indica seu p-valor. Na tabela de coeficientes, vemos que o intercepto (o valor de venda quando peso e claridade são iguais a zero, o que não faz sentido) é igual a 145.5. Vemos que tanto claridade quanto peso influenciam de modo significativo o preço do diamante, e pelo valor positivo de seus coeficientes (2.219 e 22.036), sabemos que quanto maior o valor de peso e claridade, maior o preço de venda.</p>
<p>O primeiro diamante de nossa tabela tem um peso de 9.35 e uma claridade de 0.88. Através desses valores e da equação de regressão linear que já conhecemos, podemos calcular o preço previsto para esse diamante:</p>
<p><span class="math inline">\(y=\beta_{0}+\beta_{1}x_{1}+\beta_2x_2\)</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## calculando valor estimado para o primeiro diamante da tabela

y =<span class="st"> </span><span class="fl">145.446</span> +<span class="st"> </span>(<span class="fl">2.219</span>*<span class="fl">9.35</span>) +<span class="st"> </span>(<span class="fl">22.036</span>*<span class="fl">0.88</span>)

y
<span class="co">#&gt; [1] 185.5853</span></code></pre></div>
<p>Se olharmos pedirmos para ver os valores ajustados pelo modelo, veremos que esse foi o valor previsto para esse diamante (e que foi próximo do valor real de 182.5).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## valores ajustados do modelo

<span class="kw">head</span>(modelo.diamonds$fitted.values)
<span class="co">#&gt;        1        2        3        4        5        6 </span>
<span class="co">#&gt; 185.5819 193.2105 183.3678 193.9277 189.2809 182.5417</span></code></pre></div>
</div>
<div id="hipóteses-do-modelo" class="section level2">
<h2><span class="header-section-number">2.6</span> Hipóteses do modelo</h2>
<p>Um modelo linear assume uma série de hipóteses sobre os dados (<em>assumptions</em>, em inglês) que devem ser respeitadas para que seus resultados sejam confiáveis. Winter (2013) cita algumas das hipóteses que discutimos abaixo. Se você ainda não entedê-las com a explicação que segue, consulte o material do autor.</p>
<p><br></p>
<p><strong>Linearidade</strong></p>
<p>A primeira hipótese do modelo linear é bem óbvia: é possível explicar os dados por meio de relações lineares. Se essa relação não for linear, ao plotar os resíduos do modelo contra os valores ajustados, você verá algum outro padrão, como uma curva.</p>
<p>Vamos pegar os valores ajustados e os resíduos do último modelo que fizemos e transformarmos em um <em>dataframe</em>. Depois, vamos plotar um valor contra o outro em um gráfico de dispersão.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## dataframe com os resíduos e fitted values do modelo

ajustados =<span class="st"> </span>modelo.diamonds$fitted.values
residuos =<span class="st"> </span>modelo.diamonds$residuals

aj.residuos =<span class="st"> </span><span class="kw">data.frame</span>(ajustados, residuos)

## analisando os resíduos

<span class="kw">ggplot</span>(aj.residuos, <span class="kw">aes</span>(<span class="dt">x =</span> ajustados, <span class="dt">y =</span> residuos))+
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="mlm_files/figure-html/unnamed-chunk-6-1.png" width="480" /></p>
<p>Quando o valor do resíduo é zero, é sinal que o valor previsto pelo modelo foi o valor observado. Vemos no gráfico acima que os valores dos resíduos circundam uma reta que poderíamos traçar no valor 0 do eixo y. Isso indica uma relação linear entre as variáveis. Uma relação não-linear geraria um gráfico como o da <strong>Figura 2.5</strong></p>
<div align="center">
<div class="figure">
<img src="images/winter.png" alt="Figura 2.5: Gráfico de resíduos com violação de colinearidade (Fonte: Winter 2013)" style="width:60.0%" />
<p class="caption"><strong>Figura 2.5</strong>: Gráfico de resíduos com violação de colinearidade (Fonte: Winter 2013)</p>
</div>
</div>
<p><br></p>
<p><strong>Homocedasticidade</strong></p>
<p>Essa hipótese assume que a variância dos resíduos deve ser mais ou menos homogênea para os valores ajustados; ou seja, os resíduos devem variar ao longo do valor previsto de manaeira homogênera sem demonstrar tendências. É o caso do gráfico que fizemos anteriormente, e que mostra os valores residuais homogeneamente espalhados ao redor da linha que cortaria o valor zero no eixo y.</p>
<p>Um exemplo de resíduos que descumprem essa hipótese pode ser visto na <strong>Figura 2.6</strong>. Perceba que os pontos não estão homogeneamente espalhados. Há maior concentração em determinados pontos, principalmente próximos da coordenada (0,0), e a dispersão se dá de forma heterogênea.</p>
<div align="center">
<div class="figure"><span id="fig:apagarpro1"></span>
<img src="mlm_files/figure-html/apagarpro1-1.png" alt="Violação da hipótese de homocedasticidade" width="480" />
<p class="caption">
Figure 2.5: Violação da hipótese de homocedasticidade
</p>
</div>
</div>
<p><br></p>
<p><strong>Normalidade dos resíduos</strong></p>
<p>Se você já fez análise estatística, deve ter ouvido falar da necessidade de que a distribuição das variáveis do modelo seja normal. Na verdade, a necessidade é de que os resíduos sejam normais - o que é mais fácil de ocorrer se a distribuição das variáveis for normal.</p>
<p>Como podemos testar a normalidade dos resíduos? Da mesma maneira que fazemos com as variáveis: por meio de um boxplot ou um histograma.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## histograma para normalidade de resíduos

<span class="kw">ggplot</span>(aj.residuos, <span class="kw">aes</span>(<span class="dt">x =</span> residuos))+
<span class="st">  </span><span class="kw">geom_histogram</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/unnamed-chunk-7-1.png" width="480" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## boxplot para normalidade de resíduos

<span class="kw">ggplot</span>(aj.residuos, <span class="kw">aes</span>(<span class="dt">y=</span>residuos))+
<span class="st">  </span><span class="kw">geom_boxplot</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/unnamed-chunk-7-2.png" width="480" /></p>
<p>Nos gráficos, percebemos que há simetria entre as duas caudas do histograma e do boxplot, o que indica uma distribuição normal dos resíduos.</p>
<p>Outra maneira de olhar a normalidade é através de um <strong><em>qqplot</em></strong>, ou <strong>gráfico q-q</strong> / <strong>gráfico quantil-quantil</strong> em português. Esse tipo de gráfico compara os resíduos com uma distribuição hipotética, como a normal. Para fins práticos, precisamos saber que se os resíduos seguem uma distribuição normal, eles formam uma linha reta diagonal em um gráfico de dispersão. No código abaixo, <code>stat_qq</code> plota os resíduos e <code>stat_qq_line</code> indica a linha sobre a qual esses resíduos deveriam cair em caso de distribuição normal.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## normalidade de resíduos: qqplot

<span class="kw">ggplot</span>(aj.residuos, <span class="kw">aes</span>(<span class="dt">sample=</span>residuos))+
<span class="st">  </span><span class="kw">stat_qq</span>()+
<span class="st">  </span><span class="kw">stat_qq_line</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/unnamed-chunk-8-1.png" width="480" /></p>
<p>Vemos que os resíduos acompanham essa linha de forma razoavelmente consistente, o que permite atestar sua normalidade. Na <strong>Figura 2.7</strong> temos um exemplo de distribuição não normal.</p>
<div class="figure"><span id="fig:apagarpro"></span>
<img src="mlm_files/figure-html/apagarpro-1.png" alt="Violação de normalidade" width="480" />
<p class="caption">
Figure 2.6: Violação de normalidade
</p>
</div>
<p><br></p>
<p><strong>Ausência de colinearidade</strong></p>
<p>Dizemos que dois efeitos fixos são colineares quando existe alguma correlação entre eles. Suponha que você acha que frequência de ocorrência e tamanho são duas variáveis que podem influenciar o tempo que uma pessoa leva para reconhecer uma palavra. Essas previsões fazem sentido: afinal, quanto menor a palavra, menos tempo eu levo para reconhecê-la; similarmente, eu também vou reconhecer com mais facilidade aquelas palavras que leio ou escuto mais. Uma vez que essa é minha previsão, eu poderia pensar no seguinte modelo:</p>
<div align="center">
<blockquote>
<p>tempo ~ frequencia + tamanho</p>
</blockquote>
</div>
<p>A questão (como os linguistas sabem) é que frequência e tamanho são fatores correlacionados. Palavras mais frequentes tendem a ser menores em um idioma, e palavras menos frequentes tendem a ser maiores. Desse modo, é difícil prever até que ponto cada um desses fatores contribui e como eles interagem. Se o seu modelo tiver colinearidade, vale a pena repensar seu desenho experimental ou pesquisar como resolver a questão de modo a ter resultados confiáveis.<br />
<br></p>
<p><strong>Independência</strong></p>
<p>Nas análises que fizemos aqui, cada observação veio de um participante (ou diamante) diferente: cada participante contribuiu com apenas uma medida de pitch, cada diamante com apenas uma medida de preço de venda. Podemos dizer que os dados são independentes porque todas as observações vieram de fontes diferentes, e cada fonte contribuiu com apenas uma observação.</p>
<p>No entanto, esse não é o cenário em muitas situações, principalmente quando trabalhando com desenhos experimentais. Para o experimento que procura relaciona pitch a idade, imagine que você gravou cada sujeito não apenas uma vez, mas cinco vezes. Você fez isso porque mais medidas por participante te darão uma estimativa mais confiável do pitch médio daquela pessoa. No entanto, agora há um problema. Cada participante tem suas próprias peculiaridades, e aquelas cinco medidas não são mais independentes umas das outras: elas todas se relacionam por terem sido produzidas pela mesma pessoa.</p>
<p>O modelo linear que aprendemos a construir nesta seção não é adequado para lidar com não-independência. Para isso, precisamos de uma nova classe de modelos, os <strong>modelos lineares mistos</strong>, que discutiremos na seção 3.</p>
<div id="prática-modelos-lineares" class="section level4">
<h4><span class="header-section-number">2.6.0.1</span> Prática: modelos lineares</h4>
<p>Considerando o conjunto de dados <code>linguistas.csv</code> que vimos na seção anterior, construa um modelo linear que responda à seguinte pergunta:</p>
<blockquote>
<p>O peso de uma pessoa pode ser previsto por sua altura e idade?</p>
</blockquote>
<p>Você deverá:</p>
<ul>
<li>Importar o conjunto de dados;</li>
<li>Limpar os dados para considerar apenas linguistas da UFMG, Unicamp e UFRN, ignorando a observação que tem um tamanho de pé igual a 78</li>
<li>Construir seu modelo linear e ver seus resultados;</li>
<li>Analisar os resíduos para ver se não há violação de hipóteses;</li>
<li>Escrever seus resultados como se fosse um artigo.</li>
</ul>
<p></p>
<p></p>
<p></p>
</div>
</div>
</div>
<div id="modelos-lineares-mistos-conceitos-básicos" class="section level1">
<h1><span class="header-section-number">3</span> Modelos Lineares Mistos: conceitos básicos</h1>
<blockquote>
<p><strong>Parte do texto desta seção é conteúdo de Godoy e Nunes (submetido)</strong></p>
</blockquote>
<p>Nesta seção, vamos aprender a lidar com dados de medidas repetidas, que violam a hipótese de independência. Os tópicos de que trataremos serão. Além de entendermos conceitos básicos de modelos lineares mistos, veremos como implementar esses modelos em <code>R</code> por meio do pacote <code>lme4</code>. Por fim, veremos realizar análise por modelos aninhados.</p>
<p>Enquanto você acompanha a parte introdutória do tutorial, baixe os novos pacotes que serão usados para as atividades e carregue os pacotes que serão necessários:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## baixar pacotes (esses pacotes serão carregados mais adiante)

<span class="kw">install.packages</span>(<span class="st">&quot;lme4&quot;</span>)
<span class="kw">install.packages</span>(<span class="st">&quot;lmerTest&quot;</span>)

## carregar pacotes

<span class="kw">library</span>(lme4)
<span class="kw">library</span>(ggplot2)
<span class="kw">library</span>(dplyr)

## o pacote lmerTest será carregado posteriormente</code></pre></div>
<div id="medidas-repetidas-e-efeitos-aleatórios" class="section level2">
<h2><span class="header-section-number">3.1</span> Medidas repetidas e efeitos aleatórios</h2>
<p>Até agora, assumimos que a independência é pré-requisito para aplicação dos modelos lineares vistos. No entanto, dados oriundos de corpora e experimentação dificilmente preenchem esse critério. Para ilustrar o caso, tomemos um experimento simples de <em>priming</em> semântico tal qual descrito em Godoy e Nunes (<em>submetido</em>).</p>
<p>Embora usemos um conjunto de dados diferente daquele empregado pelos autores, o problema investigado é o mesmo: um linguista apresentou a 20 participantes um total de 40 palavras alvo.</p>
<blockquote>
<p>Esses itens foram apresentados após uma palavra prime semanticamente relacionada (e.g. leite &gt; CAFÉ) ou não relacionada (pente &gt; CAFÉ). O pesquisador queria testar se a apresentação de um prime semanticamente relacionado facilitaria o reconhecimento da palavra alvo, e por isso registrou quanto tempo os participantes levavam para decidir se a palavra apresentada era ou não uma palavra do português brasileiro. (Godoy e Nunes, submetido)</p>
</blockquote>
<p>Cada participante viu 20 palavras na condição não-relacionada e 20 palavras na condição relacionada, e os dados que simulamos para esse experimento podem ser encontrados na planilha <code>priming.csv</code>, que inspecionamos com os comandos abaixo.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## importar conjunto de dados

priming &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;dados/priming.csv&quot;</span>)

## inspecionar dados

<span class="kw">head</span>(priming)
<span class="co">#&gt;      item participante       prime   SOA    tempo  resposta</span>
<span class="co">#&gt; 1 item_01         S_01 relacionado curto 688.0820   correct</span>
<span class="co">#&gt; 2 item_02         S_01 relacionado curto 694.6091   correct</span>
<span class="co">#&gt; 3 item_03         S_01 relacionado curto 499.6528 incorrect</span>
<span class="co">#&gt; 4 item_04         S_01 relacionado curto 585.7681   correct</span>
<span class="co">#&gt; 5 item_05         S_01 relacionado curto 480.8825   correct</span>
<span class="co">#&gt; 6 item_06         S_01 relacionado curto 492.4530 incorrect</span>

## conhecer variáveis

<span class="kw">str</span>(priming)
<span class="co">#&gt; &#39;data.frame&#39;:    1200 obs. of  6 variables:</span>
<span class="co">#&gt;  $ item        : Factor w/ 60 levels &quot;item_01&quot;,&quot;item_02&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...</span>
<span class="co">#&gt;  $ participante: Factor w/ 20 levels &quot;S_01&quot;,&quot;S_02&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</span>
<span class="co">#&gt;  $ prime       : Factor w/ 2 levels &quot;nrelacionado&quot;,..: 2 2 2 2 2 2 2 2 2 2 ...</span>
<span class="co">#&gt;  $ SOA         : Factor w/ 2 levels &quot;curto&quot;,&quot;longo&quot;: 1 1 1 1 1 1 1 1 1 1 ...</span>
<span class="co">#&gt;  $ tempo       : num  688 695 500 586 481 ...</span>
<span class="co">#&gt;  $ resposta    : Factor w/ 2 levels &quot;correct&quot;,&quot;incorrect&quot;: 1 1 2 1 1 2 1 1 1 1 ...</span></code></pre></div>
<p>O conjunto de dados contém 6 colunas:</p>
<blockquote>
<p><code>item</code>, com identificação das 40 palavras alvo utilizadas como itens experimentais;</p>
</blockquote>
<blockquote>
<p><code>participante</code>, com identificação dos participantes da pesquisa;</p>
</blockquote>
<blockquote>
<p><code>prime</code>, com identificação das condições de prime relacionado (<code>rel</code>) e não-relacionado (<code>nrel</code>);</p>
</blockquote>
<blockquote>
<p><code>SOA</code>, uma condição experimental que entenderemos depois;</p>
</blockquote>
<blockquote>
<p><code>tempo</code>: tempo de resposta dos participantes em milissegundos.</p>
</blockquote>
<p>Para fazer a análise dos dados, precisamos primeiro inspecioná-los e identificar possíveis <em>outliers</em>.</p>
<div id="inspeção-e-limpeza-dos-dados" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Inspeção e limpeza dos dados</h3>
<p>Como vimos anteriormente, modelos lineares mistos costumam assumir que seus resíduos seguem uma distribuição normal, e essa hipótese é mais fácil de não ser violada se a distribuição dos dados já segue essa distribuição. Portanto, convém inspecionar nossos dados para avaliar se sua distribuição é normal. Façamos isso com um gráfico Q-Q (mas você pode usar um histograma ou um boxplot se preferir).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Conferindo distribuição de dados

<span class="kw">ggplot</span>(priming, <span class="kw">aes</span>(<span class="dt">sample =</span> tempo))+
<span class="st">  </span><span class="kw">stat_qq</span>()+
<span class="st">  </span><span class="kw">stat_qq_line</span>()+
<span class="st">  </span><span class="kw">facet_wrap</span>(~prime)</code></pre></div>
<p><img src="mlm_files/figure-html/unnamed-chunk-10-1.png" width="480" /></p>
<p>Vemos que a distribuição de dados é normal, mas também identificamos alguns valores muito mais altos que os outros. Convém definir se esses valores permanecerão em nossa análise.</p>
<p>A decisão de tirar ou não observações do conjunto de dados depende de uma séries de fatores, como o fenômeno a ser modelado, a natureza experimental ou observacional dos dados, a intenção da análise estatística e (no caso de experimentos) e o tipo de tarefa feita pelo participante da pesquisa. Para experimentos de <em>priming</em>, costumamos descartar valores menores de 200ms, pois considera-se que antes desse tempo não é possível haver acesso lexical. Também podemos descartar os valores acima de 1500ms por estarem muito distantes dos valores médios, e também seguindo o que fazem alguns pesquisadores na literatura (cf. Baayen (2008) em seu capítulo sobre modelos lineares mistos).</p>
<p>Por fim, nós também vamos excluir todas as decisões que foram respondidas erroneamente pelos participantes, ou seja, todas as observações cuja resposta foi anotada com <code>incorrect</code>.</p>
<blockquote>
<p><strong>Lembre-se:</strong> os critérios de exclusão de dados foram definidos aqui pela natureza da pesquisa desenvolvida. A identificação de outliers e remoção de observações vai variar a depender de sua pergunta de pesquisa e dos dados analisados. Consulte a literatura para justificar suas decisões.</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Selecionando apenas resposta cujo tempo esteja entre 200 ms e 1500 ms e que estejam 
## marcadas como correct para a variável resposta

priming =<span class="st"> </span>priming%&gt;%
<span class="st">  </span><span class="kw">filter</span>(tempo &gt;<span class="st"> </span><span class="dv">200</span> &amp;<span class="st"> </span>tempo &lt;<span class="st"> </span><span class="dv">1500</span> &amp;<span class="st"> </span>resposta ==<span class="st"> &quot;correct&quot;</span>)

## Conferindo novamente a distribuição dos dados

<span class="kw">ggplot</span>(priming, <span class="kw">aes</span>(<span class="dt">sample =</span> tempo))+
<span class="st">  </span><span class="kw">stat_qq</span>()+
<span class="st">  </span><span class="kw">stat_qq_line</span>()+
<span class="st">  </span><span class="kw">facet_wrap</span>(~prime)</code></pre></div>
<p><img src="mlm_files/figure-html/primingSOAlimpeza-1.png" width="480" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Vendo a média (em ms) dos tempos de reação para os dois níveis da variável prime

priming%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(prime)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="kw">mean</span>(tempo))
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   prime        `mean(tempo)`</span>
<span class="co">#&gt;   &lt;fct&gt;                &lt;dbl&gt;</span>
<span class="co">#&gt; 1 nrelacionado          722.</span>
<span class="co">#&gt; 2 relacionado           675.</span></code></pre></div>
<p>Agora que temos nosso conjunto de dados, podemos fazer nossa pergunta: será que o tipo de <em>prime</em> afeta o tempo de resposta dos participantes? Vemos acima que, em média, o tempo de resposta foi menor quando o <em>prime</em> era relacionado. No entanto, será que isso é um dado confiável, ou essa diferença se deve ao acaso? Para tentar responder essa pergunta, precisamos construir um modelo linear misto que leve em conta os parâmetros do nosso conjunto de dados.</p>
</div>
<div id="modelo-linear-misto-interceptos-e-slopes-aleatórios" class="section level3">
<h3><span class="header-section-number">3.1.2</span> Modelo linear misto: interceptos e slopes aleatórios</h3>
<p>Como a hipótese do pesquisador é de que um prime relacionado diminuiria o tempo de resposta da palavra alvo, pode-se dizer que o tempo que o participante levava para tomar a decisão é a a <strong>variável resposta</strong>, e o tipo de prime (relacionado ou não) é o <strong>efeito fixo</strong>. Um modelo que quisesse testar a relação entre esse dois termos poderia ser escrito da seguinte maneira:</p>
<p><br></p>
<div align="center">
<blockquote>
<p>tempo ~ relação + <span class="math inline">\(\epsilon\)</span></p>
</blockquote>
</div>
<p><br></p>
<p>No entanto, os dados coletados pelo nosso experimentador fictício não são independentes. Lembremos que cada participante contribuiu com 20 observações para cada condição, deixando nesses dados características que são suas.</p>
<blockquote>
<p>Como cada participante é diferente, alguns serão mais rápidos, outros mais lentos, alguns estarão desconfortáveis com a tarefa, outros já terão participado de outros experimentos e estarão mais à vontade, e todos terão características próprias no modo como construíram seu vocabulário e como usam a língua no dia a dia. (Godoy e Nunes, submetido)</p>
</blockquote>
<p>Podemos ver as diferenças entre os participantes olhando o painel gerado pelo código abaixo.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Conferindo distribuição de dados por participante

<span class="kw">ggplot</span>(priming, <span class="kw">aes</span>(<span class="dt">sample =</span> tempo))+
<span class="st">  </span><span class="kw">stat_qq</span>()+
<span class="st">  </span><span class="kw">stat_qq_line</span>()+
<span class="st">  </span><span class="kw">facet_wrap</span>(~participante)</code></pre></div>
<p><img src="mlm_files/figure-html/participante-1.png" width="528" /></p>
<p>Aqui, vemos que o participante <code>S_06</code> tem muitas observações acima de 1000ms, enquanto o <code>S_20</code> não tem nenhuma. O <code>S_10</code> não tem nenhuma observação abaixo de 500ms, o que indica um tempo de reação um pouco maior que os outros participantes. De fato, se pedirmos para ver a média de resposta de cada participante, veremos resultados muito diferentes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Cálculo da média por participante

priming%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(participante)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">media =</span> <span class="kw">mean</span>(tempo))%&gt;%
<span class="st">  </span><span class="kw">arrange</span>(<span class="kw">desc</span>(media))
<span class="co">#&gt; # A tibble: 20 x 2</span>
<span class="co">#&gt;    participante media</span>
<span class="co">#&gt;    &lt;fct&gt;        &lt;dbl&gt;</span>
<span class="co">#&gt;  1 S_10          798.</span>
<span class="co">#&gt;  2 S_11          778.</span>
<span class="co">#&gt;  3 S_09          767.</span>
<span class="co">#&gt;  4 S_12          756.</span>
<span class="co">#&gt;  5 S_05          749.</span>
<span class="co">#&gt;  6 S_06          737.</span>
<span class="co">#&gt;  7 S_07          736.</span>
<span class="co">#&gt;  8 S_08          734.</span>
<span class="co">#&gt;  9 S_17          716.</span>
<span class="co">#&gt; 10 S_15          716.</span>
<span class="co">#&gt; 11 S_14          709.</span>
<span class="co">#&gt; 12 S_13          686.</span>
<span class="co">#&gt; 13 S_16          660.</span>
<span class="co">#&gt; 14 S_04          659.</span>
<span class="co">#&gt; 15 S_18          646.</span>
<span class="co">#&gt; 16 S_20          632.</span>
<span class="co">#&gt; 17 S_02          628.</span>
<span class="co">#&gt; 18 S_01          626.</span>
<span class="co">#&gt; 19 S_19          623.</span>
<span class="co">#&gt; 20 S_03          617.</span></code></pre></div>
<p>No entanto, não é apenas com relação à média geral do tempo de resposta que os participantes diferem. Considere o painel da <strong>Figura 3.1</strong>. Já vimos um gráfico parecido antes, quando discutimos o conceito de <em>slope</em>. Nessa figura, você pode ver que os participantes diferem entre entre si também em relação ao <em>slope</em> entre as condições. Os participantes <code>S_09</code> e <code>S_10</code> tem um <em>slope</em> próximo a zero. Para a maioria deles, a diferença entre o nível de referência (<code>nrel</code>) e o segundo nível da variável é dado por um slope negativo; para alguns participantes (<code>S_18</code>, <code>S_19</code> e <code>S_20</code>), esse <em>slope</em> é positivo.</p>
<p><br></p>
<div align="center">
<div class="figure"><span id="fig:unnamed-chunk-11"></span>
<img src="mlm_files/figure-html/unnamed-chunk-11-1.png" alt="Distribuição de dados por prime para cada participante" width="528" />
<p class="caption">
Figure 3.1: Distribuição de dados por prime para cada participante
</p>
</div>
</div>
<p><br></p>
<p>É razoável assumir que as características de cada participante devem influenciar suas respostas de maneiras distintas, de modo a afetar a distribuição dos dados. Isso significa que cada participante contribui com uma variabilidade aleatória, não controlada pelo experimentador, mas que deve ser prevista no modelo. Portanto, ao construirmos um modelo estatístico que tente explicar como a condição prime afeta o tempo de reação, seria adequado que esse modelo levasse em conta a variabilidade de cada participante.</p>
<p>Para usarmos a notação da sintaxe do <code>R</code>, podemos modelar essa fonte de efeito aleatório do participante da seguinte maneira:</p>
<p><br></p>
<div align="center">
<blockquote>
<p>tempo ~ prime + (1|participante)</p>
</blockquote>
</div>
<p><br></p>
<p>Aqui estamos determinando que o modelo considere interceptos diferentes para cada participante (o número 1, aqui, representa o intercepto). Esse intercepto é chamado de <strong>intercepto aleatório</strong>, visto que ele tem por objetivo modelar um fator de variabilidade aleatória: os participantes (nós podemos chamar esse intercepto específico de <strong>intercepto aleatório por participante</strong>).</p>
<p>No entanto, os participantes não são a única fonte de variabilidade não controlada pelo experimentador. Seu experimento também traz medidas repetidas por itens. O item CAFÉ, por exemplo, é visto apenas uma vez por participante, mas temos a medida de 5 participantes (e, portanto, 5 medições) para CAFÉ na condição relacionada e de 5 participantes na condição não-relacionada. É possível que essa palavra e o seu referente tenham características intrísecas como frequência, imageabilidade, vizinhança ortográfica, fonológica e lexical etc., que não são controladas pelo experimentador e que podem influenciar o tempo de resposta. O experimentador quer que seus dados possam ser generalizados para a língua estudada, e não representem apenas os itens experimentais utilizados no experimento. Clark (1973) chama isso de <strong>a falácia da língua como efeito fixo</strong>: quando observamos um dados na língua, estamos apenas observando um dado. Para generalizarmos, é preciso que se considere as possíveis variabilidades inerentes a cada dado - ou, no caso do nosso experimento, as variabilidades próprias de cada item experimental.</p>
<p>Para levar em conta essa variabilidade, ampliamos nosso modelo para que ele leve em conta mais um parâmetro: <strong>interceptos aleatórios por item</strong>.</p>
<p><br></p>
<div align="center">
<blockquote>
<p>tempo ~ prime + (1|participante) + (1|item)</p>
</blockquote>
</div>
<p><br></p>
<p>Antes de prosseguirmos, convém notarmos outro aspecto sobre o tipo de variação que participantes e itens produzem na distribuição de dados: os efeitos de <em>priming</em> podem variar em cada um deles. Na <strong>Figura 3.1</strong>, vemos que o declive da reta entre a condição não-relacionada (o valor de referência) e a condição relacionada é diferente para cada participante, e isso também é verdade para cada um dos 40 itens experimentais.</p>
<p>Portanto, além de interceptos aleatórios para itens e participantes, precisamos que nosso modelo considere também as diferenças dos declives associados a esses efeitos aleatórios em função do tipo de prime. Esse parâmetro, chamado de <strong><em>slope</em> aleatório</strong>, pode ser representado em nosso modelo da seguinte maneira:</p>
<br>
<div align="center">
<blockquote>
<p>tempo ~ prime + (1+prime|participante) + (1+prime|item)</p>
</blockquote>
</div>
<p><br></p>
<p>O que a sintaxe <code>1 + prime|participante</code> indica é “intercepto aleatório + slope aleatório por prime por participante”. Pensemos assim: para cada participante, queremos saber o quanto suas respostas variam quando ele sai do nível não-relacionado para o nível relacionado da variável <em>prime</em>. Por esse motivo, pedimos que o modelo considere o <em>slope</em> na condição <em>prime</em> para cada participante. O mesmo é feito para os itens experimentais.</p>
<p>A partir da fórmula descrita acima, criamos um <strong>Modelo Linear Misto</strong>, que recebe esse nome porque, dentre seus parâmetros, há tanto efeitos fixos quanto efeitos aleatório. Nesse modelo, o efeito fixo é a condição prime, mas se considera, ao mesmo tempo, variabilidade por item e por participante.</p>
</div>
<div id="modelos-lineares-mistos-no-pacote-lme4" class="section level3">
<h3><span class="header-section-number">3.1.3</span> Modelos lineares mistos no pacote lme4</h3>
<p>Construiremos um modelo linear, chamado <code>modelo.prime</code>. Para isso, usaremos a função <code>lmer</code> do pacote <code>lme4</code>. São dois os argumentos principais desta função. O primeiro deles é a fórmula do Modelo Linear Misto a ser ajustado, já construída anteriormente. Esta fórmula é dada por <code>tempo ~ prime + (1+prime|participante) + (1+prime|item)</code>.</p>
<p>Essa sintaxe indica que nossa variável dependente é tempo, nossa variável explicativa (ou seja, o efeito fixo) é prime, e inclui interceptos aleatórios por participante e item, além de slopes aleatórios para prime por participante e item. O segundo argumento é o objeto do <code>R</code> no qual os dados estão armazenados. Neste exemplo, nosso conjunto de dados se chama <code>priming</code>. Juntando estas duas informações, temos o seguinte:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## carregando o pacote lme4

<span class="kw">library</span>(lme4)

## ajustando modelo linear com interceptos aleatórios por item e participante e slopes 
## aleatórios por prime

modelo.prime &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime +<span class="st"> </span>(<span class="dv">1</span>+prime|participante) +<span class="st"> </span>(<span class="dv">1</span>+prime|item), 
                     <span class="dt">data =</span> priming)</code></pre></div>
<p>Ao tentarmos rodar o modelo, note que recebemos um aviso preocupante, identificado por <code>## boundary (singular) fit: see ?isSingular</code>. Isto indica que o modelo foi sobreajustado, ou seja, ele funciona muito bem para esta amostra em particular, mas não permite generalizações para a população de onde os dados foram obtidos.</p>
<blockquote>
<p>Para evitar os problemas de sobreajuste, Barr et al. (2013) sugerem que comecemos a análise da maneira que iniciamos, com a estrutura mais complexa possível para os efeitos aleatórios. Caso o modelo tenha problemas de sobreajuste ou de convergência no método iterativo, devemos simplificar esta estrutura até atingir uma convergência sem problemas. Portanto, iremos simplificar a estrutura dos efeitos aleatórios dos participantes, retirando o <em>slope</em> aleatório, mantendo apenas o intercetpo. Manteremos a estrutura dos itens da maneira inicial. (Godoy e Nunes, submetido)</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## ajustanto o modelo linear: retira slope aleatório de prime por participante 
## (continua problema de convergência) 

modelo.prime &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>+prime|item), <span class="dt">data =</span> priming)

## ajustanto o modelo linear: sem slopes aleatórios 

modelo.prime &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), <span class="dt">data =</span> priming)

## resultado de modelo.prime

<span class="kw">summary</span>(modelo.prime)
<span class="co">#&gt; Linear mixed model fit by REML [&#39;lmerMod&#39;]</span>
<span class="co">#&gt; Formula: tempo ~ prime + (1 | participante) + (1 | item)</span>
<span class="co">#&gt;    Data: priming</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; REML criterion at convergence: 14576.2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Scaled residuals: </span>
<span class="co">#&gt;      Min       1Q   Median       3Q      Max </span>
<span class="co">#&gt; -3.15182 -0.67768 -0.00772  0.65794  3.03342 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Random effects:</span>
<span class="co">#&gt;  Groups       Name        Variance Std.Dev.</span>
<span class="co">#&gt;  item         (Intercept)   635.7   25.21  </span>
<span class="co">#&gt;  participante (Intercept)  3162.3   56.23  </span>
<span class="co">#&gt;  Residual                 15275.4  123.59  </span>
<span class="co">#&gt; Number of obs: 1163, groups:  item, 60; participante, 20</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Fixed effects:</span>
<span class="co">#&gt;                  Estimate Std. Error t value</span>
<span class="co">#&gt; (Intercept)       723.068     13.963  51.786</span>
<span class="co">#&gt; primerelacionado  -48.856      7.255  -6.734</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Correlation of Fixed Effects:</span>
<span class="co">#&gt;             (Intr)</span>
<span class="co">#&gt; primerelcnd -0.259</span></code></pre></div>
<p>Desta vez, com a estrutura do efeito aleatório para os participantes simplificada, conseguimos que o modelo ajustado convergisse sem problemas. Através do comando <code>summary</code>, vemos os resultados desse modelo. Para entender os resultados, recorremos mais uma vez ao texto de Godoy e Nunes. Fazemos algumas modificações do nosso texto para fazer referência aos resultados das análises feitas aqui.</p>
<blockquote>
<p>Há, em primeiro lugar, informações sobre os efeitos aleatórios (<em>random effects</em>). Nele, vemos a variabilidade dos dados que pode ser explicada pelos efeitos aleatórios do modelo: participantes e itens. Há, ainda, informação de variabilidade residual (<em>residuals</em>), que indica a variação que não pode ser explicada pelos parâmetros explícitos no modelo. A tabela de efeitos fixos nos informa os efeitos da nossa variável independente. Vemos que há duas linhas: <code>intercept</code> e <code>primerelacionado</code>. Isso significa que o modelo assumiu a condição não-relacionada como intercepto, e está comparando a condição relacionada com ela. Por esse motivo, o coeficiente estimado para <code>intercept</code> corresponde à média de tempo de resposta para as palavras de prime relacionado [723ms]. O p-valor do <code>intercept</code> é pouco informativo nesse caso: ele assume a hipótese nula de que o valor do intercepto é igual a zero, o que não diz nada sob o efeito investigado.</p>
</blockquote>
<blockquote>
<p>A média para as palavras de prime relacionado foi [675.7ms]. Isso é [48.8ms] a menos que a média do intercepto, como evidencia o valor negativo do coeficiente para a linha <code>primerelacionado</code>. Essa linha, portanto, nos dá o valor do coeficiente estimado para a condição relacionada <em>em comparação</em> aos valores do intercepto, bem como as estatísticas associadas a esse coeficiente. (adaptado de Godoy e Nunes, submetido).</p>
</blockquote>
<p>Você deve ter notado que o resultado do modelo linear misto não é muito diferente daquele que analisamos quando vimos um modelo linear. Há, contudo, uma diferença: não há p-valor associado aos coeficientes! Se você quiser os p-valores associados aos coeficientes dos efeitos fixos, deverá carregar o pacote <code>lmerTest</code> e rodar o modelo mais uma vez.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## carregando o pacote lmerTest

<span class="kw">library</span>(lmerTest)

## ajustanto o modelo linear 

modelo.prime &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), <span class="dt">data =</span> priming)

## resultado de modelo.prime

<span class="kw">summary</span>(modelo.prime)
<span class="co">#&gt; Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [</span>
<span class="co">#&gt; lmerModLmerTest]</span>
<span class="co">#&gt; Formula: tempo ~ prime + (1 | participante) + (1 | item)</span>
<span class="co">#&gt;    Data: priming</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; REML criterion at convergence: 14576.2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Scaled residuals: </span>
<span class="co">#&gt;      Min       1Q   Median       3Q      Max </span>
<span class="co">#&gt; -3.15182 -0.67768 -0.00772  0.65794  3.03342 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Random effects:</span>
<span class="co">#&gt;  Groups       Name        Variance Std.Dev.</span>
<span class="co">#&gt;  item         (Intercept)   635.7   25.21  </span>
<span class="co">#&gt;  participante (Intercept)  3162.3   56.23  </span>
<span class="co">#&gt;  Residual                 15275.4  123.59  </span>
<span class="co">#&gt; Number of obs: 1163, groups:  item, 60; participante, 20</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Fixed effects:</span>
<span class="co">#&gt;                  Estimate Std. Error       df t value Pr(&gt;|t|)    </span>
<span class="co">#&gt; (Intercept)       723.068     13.963   24.462  51.786  &lt; 2e-16 ***</span>
<span class="co">#&gt; primerelacionado  -48.856      7.255 1085.552  -6.734 2.67e-11 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Correlation of Fixed Effects:</span>
<span class="co">#&gt;             (Intr)</span>
<span class="co">#&gt; primerelcnd -0.259</span></code></pre></div>
<p>A interpretação, aqui, não diverge do que vimos no encontro anterior, quando aprendemos a ler o output de um modelo linear. Contudo, quando trabalhamos com modelos lineares costumamos testar seus efeitos através de um expediente chamado <strong>comparação por modelos aninhados</strong>.</p>
<div id="tarefa-entendendo-artigos" class="section level4">
<h4><span class="header-section-number">3.1.3.1</span> Tarefa: entendendo artigos</h4>
<p>Antes de seguirmos nosso tutorial, vamos fazer uma pausa para fixar o que você aprendeu. Abaixo há a descrição de modelos lineares feitas por dois artigos. Tente escrever como seria a sintaxe que esses artigos estão descrevendo. Não se esqueça de informar que função - <code>lmer()</code> ou <code>lm()</code> - você usaria.</p>
<blockquote>
<p><strong>Modelo 1</strong> <em>“a linear mixed-effects model was fit using residual reading time as the dependent variable, region as the fixed effect, and participant and item as random effects”</em> (Enochson e Culbertson 2015)</p>
</blockquote>
<blockquote>
<p><strong>Modelo 2</strong> <em>“we use a linear model analysis with body-N condition and language (…) as the independent variables and body-N, as a continuous measure, as the dependent variable.”</em> (Schmalz et al. preprint)</p>
</blockquote>
<blockquote>
<p><strong>Modelo 3</strong> <em>“After removing data points with RTs &lt; 300ms or &gt; 1800ms (which resulted in an approximately normal distribution of the data, as shown by a qqplot), we were left with a total of 2268 data observations. These data were fit with an LME model including random intercepts for both participants and items, as well as a fixed effect of body-N as a continuous predictor. The dependent variable was inverse RTs.”</em> (Schmalz et al. preprint)</p>
</blockquote>
</div>
</div>
</div>
<div id="comparação-por-modelos-aninhados" class="section level2">
<h2><span class="header-section-number">3.2</span> Comparação por modelos aninhados</h2>
<p>O modelo apresentado na seção anterior mostra como conseguimos lidar com a variabilidade de itens e participantes em um único modelo. Para fins didáticos, usamos a função <code>summary()</code> para analisar os coeficientes do modelo, o que poderia nos levar a imaginar que os passos lógicos para análise de resultados em um MLM são (a) construir o modelo com todas os efeitos (fixos e aleatórios) previstos; (b) reportar seus coeficientes. No entanto, há uma diferença no modo de se reportar p-valores e construir modelos quando lidamos com MLMs. Em vez de simplesmente reportar os coeficientes do modelo mais completo, fazemos uma <strong>comparação por modelos aninhados</strong> para, primeiramente, chegar ao modelo que melhor explica os dados obtidos de maneira mais parcimoniosa. Isso é feito por um teste de razão de verossimilhança. Nas palavras de Winter (2013),</p>
<blockquote>
<p>“Verossimilhança é a probabilidade de ver seu conjunto de dados dado o seu modelo. A lógica do teste de razão de verossimilhança é comparar a verossimilhança de dois modelos entre si. Primeiro, o modelo sem o fator de interesse (…), e depois o modelo com o fator em que se está interessado” (pg. 12)</p>
</blockquote>
<p>No experimento analisado, temos apenas o tipo de prime como efeito fixo. Isso significa que queremos saber se os dados coletados tem maior probabilidade de ocorrer dado um modelo que <em>tenha</em> o efeito fixo prime em comparação a um modelo que <em>não tenha</em> esse mesmo efeito fixo. O primeiro passo para a comparação é construir dois modelos que difiram entre si apenas pela ausência da variável de interesse.</p>
<p>É o que ocorre entre <code>modelo.prime</code> (que repetimos abaixo para incluir o argumento REML<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>) e <code>modelo.nulo</code>. Na sequência, o teste de razão de verossimilhança é feito com a função <code>anova()</code>. Esse tipo de comparação é chamada de comparação de modelos aninhados pelo fato de o modelo mais simples estar contido (<em>i.e.</em>, aninhado) no modelo mais completo.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## criando modelo completo e modelo aninhado

modelo.nulo  &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span><span class="dv">1</span> +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), <span class="dt">data =</span> priming, 
                     <span class="dt">REML =</span> <span class="ot">FALSE</span>)

modelo.prime &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), <span class="dt">data =</span> priming, 
                     <span class="dt">REML =</span> <span class="ot">FALSE</span>)

## comparação de modelos

<span class="kw">anova</span>(modelo.nulo, modelo.prime)
<span class="co">#&gt; Data: priming</span>
<span class="co">#&gt; Models:</span>
<span class="co">#&gt; modelo.nulo: tempo ~ 1 + (1 | participante) + (1 | item)</span>
<span class="co">#&gt; modelo.prime: tempo ~ prime + (1 | participante) + (1 | item)</span>
<span class="co">#&gt;              Df   AIC   BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)    </span>
<span class="co">#&gt; modelo.nulo   4 14642 14662 -7316.7    14634                             </span>
<span class="co">#&gt; modelo.prime  5 14599 14624 -7294.5    14589 44.406      1  2.669e-11 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></code></pre></div>
<p>Conforme destacam Godoy e Nunes (submetido) sobre a análise de resultados,</p>
<blockquote>
<p>o próprio <em>output</em> explica quais foram os modelos considerados nesta análise. Para que os modelos sejam comparáveis, eles devem estar aninhados: <code>modelo.nulo</code> indica que este MLM não possui efeito de prime, enquanto <code>modelo.prime</code> possui este efeito.</p>
</blockquote>
<blockquote>
<p>Além disso, cada coluna da tabela reposta neste <em>output</em> possui seu próprio significado. <code>Df</code> indica o número de graus de liberdade de cada modelo. As colunas <code>AIC</code> e <code>BIC</code> são estatísticas chamadas Akaike Information Criteria e Bayaesian Information Criteria. Elas servem como auxiliares na escolha do melhor modelo para os dados analisados. Não existe um valor de referência para estas estatísticas. Vamos escolher os modelos que possuam o menor valor de <code>AIC</code> ou <code>BIC</code>. Entretanto, esta decisão precisa ser tomada a partir de um teste de hipóteses realizado por meio de um Teste de Razão de Verossimilhanças.</p>
</blockquote>
<p>Não entraremos em detalhes sobre como o teste é feito (cf. Godoy e Nunes para maiores informações), mas podemos ver seu resultado nas últimas últimas três colunas deste <em>output</em>. Temos <code>Chisq</code>, que informa o valor da estatística, <code>Chi Df</code>, que informa quantos graus de liberdade esta estatística possui, e, finalmente, <code>Pr(&gt;Chisq)</code>, indicando o p-valor do teste.</p>
<p>Como o p-valor reportado está abaixo da taxa de erros do Tipo I <span class="math inline">\(\alpha = 0.05\)</span>, a comparação indica que <strong>houve diferença na verossimilhança entre os modelos</strong>. Seguindo o padrão de escrita sugerido em Godoy e Nunes (submetido), nosso pesquisador fictício deveria reportar os resultados com um texto como</p>
<blockquote>
<p>“ajustamos um Modelo Linear Misto com tempo de reação como variável resposta, prime como variável preditora e interceptos aleatórios para participantes e itens. Uma comparação com modelos aninhados indicou que prime contribui significativamente para o modelo (<span class="math inline">\(\chi^2\)</span> = 44.406, p &lt; 0.0001)”.</p>
</blockquote>
<p>Dizemos, então, que o melhor modelo ajustado foi o modelo com prime como efeito fixo (além de todos os efeitos aleatórios já citados). Se o pesquisador assim desejasse, poderia complementar esse resultado publicado a tabela com os coeficientes do melhor modelo ajustado. O crucial aqui é entender que a tabela de coeficientes deve ser analisado <em>depois</em> de se identificar o melhor modelo ajustado, e que se publica justamente a tabela do <em>melhor</em> modelo, e não do <em>maior</em> modelo.</p>
<p>Esse exemplo é didático por ser simples, mas frequentemente queremos ver o efeito de duas ou mais variáveis sobre uma variável resposta. Vejamos como fica a comparação por modelos aninhados com um modelo um pouco mais complexo.</p>
</div>
<div id="modelos-lineares-mistos-com-duas-variáveis-e-interação" class="section level2">
<h2><span class="header-section-number">3.3</span> Modelos lineares mistos com duas variáveis e interação</h2>
<p>Imaginemos o mesmo experimento de <em>priming</em> semântico, mas dessa vez com uma segunda variável. Além de controlar a relação entre prime e alvo, nosso experimentador controlou também o tempo entre a exibição das duas palavras. Essa variável é chamada de <em>Stimulus Onset Asynchrony</em>, ou SOA. Para metade dos itens, o prime aparecia 650ms após a apresentação da palavra alvo; para a outra metade, essa diferença de tempo era de 350ms.</p>
<p>Vamos dar uma olhada novamente no conjunto de dados para ver como as informações estão dispostas no <em>dataframe</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## relembrando conjunto de dados

<span class="kw">head</span>(priming)
<span class="co">#&gt;      item participante       prime   SOA    tempo resposta</span>
<span class="co">#&gt; 1 item_01         S_01 relacionado curto 688.0820  correct</span>
<span class="co">#&gt; 2 item_02         S_01 relacionado curto 694.6091  correct</span>
<span class="co">#&gt; 3 item_04         S_01 relacionado curto 585.7681  correct</span>
<span class="co">#&gt; 4 item_05         S_01 relacionado curto 480.8825  correct</span>
<span class="co">#&gt; 5 item_07         S_01 relacionado curto 742.2370  correct</span>
<span class="co">#&gt; 6 item_09         S_01 relacionado curto 546.7260  correct</span></code></pre></div>
<p>Além das colunas que já usamos na análise anterior, vemos que há uma coluna chamada <code>SOA</code> com identificação das condições de SOA de 350ms (<code>curto</code>) e 650ms (<code>longo</code>).</p>
<blockquote>
<p><strong>ATENÇÃO!</strong> Não precisaremos inspecionar e limpar o conjunto de dados pois já fizemos isso antes, mas não se esqueça de sempre começar sua análise por esses passos!</p>
</blockquote>
<p>A partir dessa nova variável, convém pensar nas hipóteses do experimento e em como isso se reflete nos efeitos fixos e aleatórios do modelo linear a ser construído.</p>
<p>O pesquisador não está interessado em ver se SOAs diferentes influenciam o tempo de reconhecimento das palavras alvo de modo geral, mas em verificar se há <strong>interação</strong> entre os SOA e tipo de prime. A hipótese é de que o efeito de <em>priming</em> seria mais forte com um SOA maior, visto que o participante teria mais tempo para acessar palavras relacionadas à palavra prime. Contudo, isso só será sentido nas palavras de prime relacionado, uma vez que na condição de prime não-relacionado não se espera qualquer efeito de facilitação de acesso da palavra alvo, independente do SOA.</p>
<p>Portanto, temos três <strong>efeitos fixos</strong> que podem explicar a distribuição de dados: <em>prime</em>, <em>SOA</em> e <em>interação entre prime e SOA</em>. A variável resposta, como sempre, é o tempo de reação.</p>
<p>Essa relação entre efeitos fixos e variável resposta pode ser modelada através da equação abaixo, em que <code>prime:SOA</code> indica a interação entre <code>prime</code>e <code>SOA</code>.</p>
<div align="center">
<blockquote>
<p>tempo ~ prime + SOA + prime:SOA</p>
</blockquote>
</div>
<p>Abaixo vemos uma outra maneira (mais econômica) de escrever a mesma equação. O asterisco entre dois efeitos fixos indica que o modelo está assumindo os dois efeitos individualmente <em>mais</em> a interação entre eles.</p>
<div align="center">
<blockquote>
<p>tempo ~ prime * SOA</p>
</blockquote>
</div>
<p>Para implementar nossa análise no <code>R</code>, seguimos os mesmos passos já utilizados antes. Primeiramente, construímos nosso MLM indicando a estrutura máxima de efeitos aleatórios. Isso inclui não apenas <strong>interceptos aleatórios</strong> para participantes e itens, mas também <strong><em>slopes</em> aleatórios</strong> para prime, SOA e a interação entre esses dois fatores.</p>
<p>Você verá que há um problema de ajuste no modelo, como vimos antes. Isso é bastante comum. Seguimos removendo parâmetros da estrutura de efeitos aleatórios até que nosso modelo consiga convergir.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## construção do modelo completo (erro de convergência)

model.full &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime*SOA +<span class="st"> </span>(<span class="dv">1</span>+prime*SOA|participante) +<span class="st"> </span>(<span class="dv">1</span>+prime*SOA|item), 
                   <span class="dt">data =</span> priming, <span class="dt">REML=</span><span class="ot">FALSE</span>)
<span class="co">#&gt; Warning: Model failed to converge with 1 negative eigenvalue: -1.5e+00</span>

## remoção de slopes para participante (erro de convergência)

model.full &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime*SOA +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>+prime*SOA|item), 
                   <span class="dt">data =</span> priming, <span class="dt">REML=</span><span class="ot">FALSE</span>)

## remoção de slopes para item

model.full &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime*SOA +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), 
                   <span class="dt">data =</span> priming, <span class="dt">REML=</span><span class="ot">FALSE</span>)</code></pre></div>
<p>Conseguimos alcançar convergência com o terceiro modelo, que tem prime, SOA e a interação entre essas condições como efeito fixo, além de interceptos aleatórios para participante e item.</p>
<p>Seguindo uma análise por modelos aninhados, comparamos esse modelo com um seguinte, chamado <code>model.prime.SOA</code>, que difere de <code>model.full</code> apenas pela ausência de interação entre prime e SOA. Comparando os dois modelos podemos ver se a presença do parâmetro de interação explica os dados de maneira significatica.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## modelo sem interação

model.prime.SOA &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime+SOA +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), 
                        <span class="dt">data =</span> priming, <span class="dt">REML=</span><span class="ot">FALSE</span>)

## comparação de modelos aninhados

<span class="kw">anova</span>(model.full, model.prime.SOA)
<span class="co">#&gt; Data: priming</span>
<span class="co">#&gt; Models:</span>
<span class="co">#&gt; model.prime.SOA: tempo ~ prime + SOA + (1 | participante) + (1 | item)</span>
<span class="co">#&gt; model.full: tempo ~ prime * SOA + (1 | participante) + (1 | item)</span>
<span class="co">#&gt;                 Df   AIC   BIC  logLik deviance Chisq Chi Df Pr(&gt;Chisq)</span>
<span class="co">#&gt; model.prime.SOA  6 14600 14631 -7294.2    14588                        </span>
<span class="co">#&gt; model.full       7 14602 14638 -7294.1    14588 0.162      1     0.6873</span>

## Resultado: interação não é significativo</code></pre></div>
<p>O p-valor da comparação acima indica que retirar a interação do modelo não muda seu ajuste de forma significativa, o que significa que devemos ficar com o modelo <code>model.prime.SOA</code>, mais parcimonioso. A partir de agora, usaremos esse modelo para continuar investigando se podemos ter um modelo ainda mais simples que explique a distribuição dos dados.</p>
<p>Para saber se o tipo de SOA contribui para o ajuste de modelo, comparamos <code>model.prime.SOA</code> com o modelo aninhado <code>model.prime</code> que difere apenas pela ausência de SOA.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## modelo com prime, sem SOA

model.prime &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), 
                    <span class="dt">data =</span> priming, <span class="dt">REML=</span><span class="ot">FALSE</span>)

## comparação de modelos aninhados

<span class="kw">anova</span>(model.prime.SOA, model.prime)
<span class="co">#&gt; Data: priming</span>
<span class="co">#&gt; Models:</span>
<span class="co">#&gt; model.prime: tempo ~ prime + (1 | participante) + (1 | item)</span>
<span class="co">#&gt; model.prime.SOA: tempo ~ prime + SOA + (1 | participante) + (1 | item)</span>
<span class="co">#&gt;                 Df   AIC   BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)</span>
<span class="co">#&gt; model.prime      5 14599 14624 -7294.5    14589                         </span>
<span class="co">#&gt; model.prime.SOA  6 14600 14631 -7294.2    14588 0.6709      1     0.4127</span>

## Resultado: SOA não é significativo</code></pre></div>
<p>Os resultados da comparação de modelos mostram que, ao retirar o SOA do modelo, seu ajuste não muda de forma significativa. Isso significa que, de modo geral, um modelo com SOA e sem SOA faz o mesmo trabalho em explicar a distribuição dos dados.</p>
<p>Para testar se o efeito fixo prime influencia significativamente no modelamento dos tempos de reação, seguimos o mesmo passo: comparamos o <code>modelo.prime.SOA</code> com um modelo aninhado <code>modelo.SOA</code>, que diferen apenas pela ausência do efeito de prime.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## modelo sem interação

model.SOA &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>SOA +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), 
                  <span class="dt">data =</span> priming, <span class="dt">REML=</span><span class="ot">FALSE</span>)
<span class="co">#&gt; Warning in checkConv(attr(opt, &quot;derivs&quot;), opt$par, ctrl = control$checkConv, :</span>
<span class="co">#&gt; Model failed to converge with max|grad| = 0.00667214 (tol = 0.002, component 1)</span>

## comparação de modelos aninhados

<span class="kw">anova</span>(model.prime.SOA, model.SOA)
<span class="co">#&gt; Data: priming</span>
<span class="co">#&gt; Models:</span>
<span class="co">#&gt; model.SOA: tempo ~ SOA + (1 | participante) + (1 | item)</span>
<span class="co">#&gt; model.prime.SOA: tempo ~ prime + SOA + (1 | participante) + (1 | item)</span>
<span class="co">#&gt;                 Df   AIC   BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)    </span>
<span class="co">#&gt; model.SOA        5 14643 14668 -7316.4    14633                             </span>
<span class="co">#&gt; model.prime.SOA  6 14600 14631 -7294.2    14588 44.356      1  2.737e-11 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>

## Resultado: prime é significativo</code></pre></div>
<p>O resultado da última comparação de modelos aninhados nos mostra que prime influencia significativamente a distribuição dos dados. Isso significa que <code>model.prime</code> é o melhor modelo ajustado para nossos dados, e agora sim podemos ver seus coeficientes. Para analisarmos seus resultados, repetimos abaixo a média de tempo de reação para cada uma de nossas condições.</p>
<blockquote>
<p><strong>ATENÇÃO!</strong> Idealmente vemos as médias, medianas e outras medidas descritivas no primeiro momento da análise, quando olhamos a distribuição dos dados. Apenas para fins didáticos adiamos esse momento nesse tutorial.</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## médias dos tempos de reação

priming%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(prime)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="kw">mean</span>(tempo))
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   prime        `mean(tempo)`</span>
<span class="co">#&gt;   &lt;fct&gt;                &lt;dbl&gt;</span>
<span class="co">#&gt; 1 nrelacionado          722.</span>
<span class="co">#&gt; 2 relacionado           675.</span>

## coeficientes do melhor modelo ajustado

<span class="kw">summary</span>(model.prime)
<span class="co">#&gt; Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s</span>
<span class="co">#&gt;   method [lmerModLmerTest]</span>
<span class="co">#&gt; Formula: tempo ~ prime + (1 | participante) + (1 | item)</span>
<span class="co">#&gt;    Data: priming</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      AIC      BIC   logLik deviance df.resid </span>
<span class="co">#&gt;  14599.1  14624.4  -7294.5  14589.1     1158 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Scaled residuals: </span>
<span class="co">#&gt;     Min      1Q  Median      3Q     Max </span>
<span class="co">#&gt; -3.1548 -0.6786 -0.0094  0.6583  3.0336 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Random effects:</span>
<span class="co">#&gt;  Groups       Name        Variance Std.Dev.</span>
<span class="co">#&gt;  item         (Intercept)   633.1   25.16  </span>
<span class="co">#&gt;  participante (Intercept)  3001.0   54.78  </span>
<span class="co">#&gt;  Residual                 15262.4  123.54  </span>
<span class="co">#&gt; Number of obs: 1163, groups:  item, 60; participante, 20</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Fixed effects:</span>
<span class="co">#&gt;                  Estimate Std. Error       df t value Pr(&gt;|t|)    </span>
<span class="co">#&gt; (Intercept)       723.065     13.668   26.001  52.901  &lt; 2e-16 ***</span>
<span class="co">#&gt; primerelacionado  -48.850      7.252 1086.407  -6.736 2.64e-11 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Correlation of Fixed Effects:</span>
<span class="co">#&gt;             (Intr)</span>
<span class="co">#&gt; primerelcnd -0.265</span></code></pre></div>
<p>Conseguimos ver que o coeficiente mostra a diferença entre o prime relacionado e o intercept, que, por sua vez, indica a média do prime não-relacionado. Isso não é nada diferente do que já vimos antes.</p>
<p>Podemos reportar esses dados da seguinte maneira:</p>
<blockquote>
<p>“Tomando o tempo de reação como variável resposta, ajustamos um modelo linear misto com prime, SOA e interação entre os dois fatores como efeitos fixos e interceptos aleatórios por item e participante. Uma comparação com modelos aninhados mostrou que nem a interação entre prime e SOA (<span class="math inline">\(\chi^2\)</span> = 0.1191, p = 0.7) e nem SOA (<span class="math inline">\(\chi^2\)</span> = 1.309, p = 0.25) tiveram efeito significativo, mas que o melhor modelo ajustado continha apenas prime como efeito fixo (<span class="math inline">\(\chi^2\)</span> = 41.966, p &lt; 0.0001).”</p>
</blockquote>
</div>
<div id="slopes-e-efeitos-aleatórios" class="section level2">
<h2><span class="header-section-number">3.4</span> Slopes e efeitos aleatórios</h2>
<p>Os exemplos que demos aqui nos levaram a considerar slopes aleatórios dos efeitos fixos (prime e SOA) por participante e por item. No entanto, nem sempre isso é o correto. Imagine um experimento de decisão lexical que controle duas variáveis: frequência da palavra (palavras de alta frequência e baixa frequência) e língua nativa (falante nativo ou não-nativo).</p>
<p>Participantes veriam palavras na tela de um computador e deveriam decidir se elas são ou não palavras do português. No entanto, metade dos participantes são falantes nativos de português e metade não são. Além disso, as palavras escolhidas eram ou palavras frequentes do português ou palavras de baixa frequência, que quase nunca ocorrem. Queremos modelar os tempos de resposta a partir da seguinte equação:</p>
<blockquote>
<p>tempo ~ frequência + lingua</p>
</blockquote>
<p>Se fôssemos construir um MLM com arquitetura máxima de efeitos aleatórios, poderímos imagianar uma sintaxe como a que vemos em (a):</p>
<blockquote>
<ol style="list-style-type: lower-alpha">
<li><blockquote>
<p>tempo ~ frequencia + lingua + (1+frequencia+lingua|item) + (1+frequencia+lingua|participante)</p>
</blockquote></li>
</ol>
</blockquote>
<p>Contudo, essa sintaxe está errada. Quando ajustamos algo como <code>(1+lingua|participante)</code>, estamos pedindo para considerar a mudança (dada pelo <em>slope</em>) do mesmo participante quando ele é e quando ele não é falante nativo de português; ou seja, como o comportamento dele se altera quando ele sai de um a outro nível da variável <code>falante nativo</code>. Isso é incoerente, já que uma pessoa não pode ser e não ser ao mesmo tempo falante nativo de um idioma. Similarmente <code>(1+frequencia|item)</code> indica que o modelo tentará ajustar um slope para cada item a fim de buscar seu comportamenteo quando ele muda de um nível a outro da variável frequência. Ora, a frequência de uma palavra em uma língua é uma só, ela não muda.</p>
<p>Por esses motivos, a sintaxe adequada seria o que vemos em (b).</p>
<blockquote>
<ol start="2" style="list-style-type: lower-alpha">
<li>tempo ~ frequencia*lingua + (1+lingua|item) + (1+frequencia|participante)</li>
</ol>
</blockquote>
<p>A sintaxe em (b) está correta porque cada item foi visto por participantes que tinham português como língua nativa ou não, e cada participante viu palavras de alta e baixa frequência.</p>
<p>É importante prestar atenção a como seus efeitos aleatório se relacionam com os efeitos fixos para acertar a arquitetura de efeitos aleatórios do seu modelo.</p>
</div>
<div id="distribuição-dos-dados-transformação-logarítmica" class="section level2">
<h2><span class="header-section-number">3.5</span> Distribuição dos dados: transformação logarítmica</h2>
<p>Vimos na seção anterior que a hipótese da normalidade se aplica aos resíduos de um modelo linear, e não às suas variáveis. Se fossemos continuar as análises acima, teríamos que fazer uma análise por resíduos (você pode tentar fazer depois, para praticar).</p>
<p>No entanto, se as variáveis do modelo não têm uma distribuição normal, é mais raro que a distribuição dos resíduos seja normal também. Por esse motivo, é comum que algumas pesquisadores busquem <em>normalizar</em> suas variáveis antes de dar início a sua análise. A maneira mais comum de fazer a normalização é através de uma transformação logarítmica nos dados.</p>
<p>Vamos importar e inspecionar o conjunto de dados <code>tempo.csv</code>, que traz apenas uma coluna com tempos de resposta em milissegundos. Construímos um <em>qqplot</em> e um histograma para ver que sua distribuição não é normal.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## importando conjunto de dados tempo

tempo =<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;dados/tempo.csv&quot;</span>)

## inspecionando (apenas 1 variável numérica chamada tempo)

<span class="kw">str</span>(tempo)
<span class="co">#&gt; &#39;data.frame&#39;:    192 obs. of  1 variable:</span>
<span class="co">#&gt;  $ tempo: num  590 610 842 859 474 ...</span>

## inspecionando distribuição

<span class="kw">ggplot</span>(tempo, <span class="kw">aes</span>(<span class="dt">sample =</span> tempo))+
<span class="st">  </span><span class="kw">stat_qq</span>(<span class="dt">alpha=</span><span class="fl">0.3</span>)+
<span class="st">  </span><span class="kw">stat_qq_line</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/unnamed-chunk-12-1.png" width="480" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">ggplot</span>(tempo, <span class="kw">aes</span>(<span class="dt">x =</span> tempo))+
<span class="st">  </span><span class="kw">geom_histogram</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/unnamed-chunk-12-2.png" width="480" /></p>
<p>Essa distribuição não é normal: tem uma cauda assimétrica e longa à direita. Portanto, vamos normalizar esses valores. Criaremos uma nova coluna no <em>dataframe</em> tempo, chamada <code>tempo.log</code>. Essa nova coluna leverá os valores logarítmicos daqueles valores da coluna <code>tempo</code>.</p>
<p>Rode o código abaixo e você verá, no painel <em>Environment</em>, que o <em>dataframe</em> tem agora duas colunas. Você pode até inspecioná-lo para conferir.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## criar coluna com valor log(tempo)

tempo$log.tempo =<span class="st"> </span><span class="kw">log</span>(tempo$tempo)

## inspecionando a nova coluna

<span class="kw">str</span>(tempo)
<span class="co">#&gt; &#39;data.frame&#39;:    192 obs. of  2 variables:</span>
<span class="co">#&gt;  $ tempo    : num  590 610 842 859 474 ...</span>
<span class="co">#&gt;  $ log.tempo: num  6.38 6.41 6.74 6.76 6.16 ...</span></code></pre></div>
<p>Você pode ver agora que a distribuição desses valores é normal, e portanto deveria seguir sua análise considerando esses dados transformados como sua variável resposta.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">

## inspecionando nova distribuição

<span class="kw">ggplot</span>(tempo, <span class="kw">aes</span>(<span class="dt">sample =</span> log.tempo))+
<span class="st">  </span><span class="kw">stat_qq</span>(<span class="dt">alpha=</span><span class="fl">0.3</span>)+
<span class="st">  </span><span class="kw">stat_qq_line</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/unnamed-chunk-14-1.png" width="480" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">ggplot</span>(tempo, <span class="kw">aes</span>(<span class="dt">x =</span> log.tempo))+
<span class="st">  </span><span class="kw">geom_histogram</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/unnamed-chunk-14-2.png" width="480" /></p>
<p><br></p>
<p>Agora que os dados estão normalizados, poderíamos seguir com as análises normalmente, usando como variável esse novo valor transformado, e não o valor bruto.</p>
<p>Algumas perguntas que você pode ter sobre transformação de valores são as seguintes:</p>
<p><br></p>
<ul>
<li>Essa é a única maneira de lidar com dados que violam a hipótese de normalidade?</li>
</ul>
<p>Não. Uma outra maneira é buscar outros modelos estatísticos que não assumam normalidade dos resíduos. Para lidar com dados com medidas repetidas, há poucas opções desse tipo e vai depender do tipo de distribuição que você tem. Os dados que temos acima se assemelham a uma distribuição gama. Uma possibilidade seria ajustar um <strong>modelo linear generalizado</strong> (mais sobre isso na Seção 5) que assuma uma família de distribuições do tipo gama. Há autores que argumentam que essa é a melhor maneira de tratar dados que violam a normalidade, e que devemos preferir essa solução a uma transformação logarítmica (Lo e Andrews 2015). No entanto, em algumas áreas de estudo (como na psicologia e psicolinguística) é comum que os pesquisadores prefiram transformar seus dados.</p>
<p><br></p>
<ul>
<li>O que fazer quando, mesmo com a transformação, os dados continuam violando a normalidade?</li>
</ul>
<p>Há duas respostas possíveis. A primeira é fazer a análise da mesma maneira e ver se os resíduos não tendem à normalidade. Lembre-se: a normalidade é uma hipótese sobre os resíduos do seu modelo.</p>
<p>Outra possibilidade seria procurar um modelo linear generalizado que não assuma a hipótese da normalidade, como discutido na questão anterior.</p>
<p>Qualquer que seja sua decisão, lembre-se de justificá-la com base na literatura da área. Às vezes nós não fazemos a melhor análise para os dados, mas sim a <em>melhor análise disponível</em>, e isso é muito diferente… A estatística também é uma área de estudos dinâmica, e há problemas de estatística aplicada para os quais ainda não temos respostas. Nesse caso, sacrificamos um pouco a precisão dos nossos modelos (e temos que decidir o que sacrificar) para fazer as análises que são possíveis naquele momento.</p>
</div>
<div id="resumindo-o-modelo-linear-misto" class="section level2">
<h2><span class="header-section-number">3.6</span> Resumindo o modelo linear misto</h2>
<ul>
<li><p>Um modelo linear misto recebe esse nome porque conta com efeitos fixos e aleatórios;</p></li>
<li><p>Iniciamos nossa análise construindo um modelo com o maior número possível de parâmetros de efeitos aleatórios, o que inclui interceptos e slopes aleatórios;</p></li>
<li><p>Vamos diminuindo esses parâmatros se houver problemas de convergência;</p></li>
<li><p>Ao chegarmos em um modelo máximo ajustado, prosseguimos a análise por comparação de modelos aninhados para determinar qual é o melhor e mais parcimonioso modelo ajustado aos dados;</p></li>
<li><p>Precisamos conferir se nossos dados cumprem os requisitos para a construção de um modelo linear misto, o que inclui os requisitos vistos na última aula e a inclusão de medidas repetidas na estrutura de dados.</p></li>
</ul>
<p>Se quiser saber mais sobre modelos lineares, consulte Baayen et al. (2008). Para um outro tutorial, veja Winter (2013). Para uma explicação sobre o porquê o uso de modelos lineares mistos é melhor do que uma ANOVA, veja Godoy e Nunes (submetido).</p>
</div>
<div id="prática-1" class="section level2">
<h2><span class="header-section-number">3.7</span> Prática</h2>
<p>O conjunto de dados <em>prediction.xlsx</em> contém os tempos de leitura de palavras críticas lidas durante um experimento de leitura auto-cadenciada que controlou 2 variáveis: tipo de contexto e tipo de palavra.</p>
<p>Os contextos eram de dois tipos: um <strong>contexto preditivo</strong>, que construía uma história em que uma palavra era esperada (“pedido”, no exemplo (1) abaixo), e um <strong>contexto não-preditivo</strong>, que não fazia com que qualquer palavra fosse particularmente esperada (caso do exemplo em (2)).</p>
<p>As palavras também eram de dois tipos: <strong>palavra esperada</strong> (“pedido”) ou <strong>palavra inesperada</strong> (“mensagem”) a partir do contexto preditivo.</p>
<p><br></p>
<ol style="list-style-type: decimal">
<li><p><strong>Contexto preditivo e palavra esperada:</strong> A garçonete anotou o pedido.</p></li>
<li><p><strong>Contexto preditivo e palavra inesperada:</strong> A garçonete anotou a mensagem.</p></li>
<li><p><strong>Contexto não-preditivo e palavra esperada:</strong> Joana anotou o pedido.</p></li>
<li><p><strong>Contexto não-preditivo e palavra inesperada:</strong> Joana anotou a mensagem.</p></li>
</ol>
<p><br></p>
<p>A hipótese do estudo era de que as palavras esperadas seriam lidas mais rapidamente que as inesperadas apenas no contexto preditivo. Para isso, coletou-se o tempo de leitura de cada palavra crítica de sentenças semelhantes às apresentadas acima.</p>
<p>O conjunto de dados tem 6 colunas:</p>
<ul>
<li><p><code>cod</code>, com identificação das 40 palavras alvo utilizadas como itens experimentais;</p></li>
<li><p><code>participante</code>, com identificação dos participantes da pesquisa;</p></li>
<li><p><code>rt</code>, com o tempo de leitura da palavra crítica;</p></li>
<li><p><code>contexto</code>, com indicação de contexto preditivo (<code>preditivo</code>) ou não-preditivo (<code>npreditivo</code>);</p></li>
<li><p><code>palavra</code>, com indicação se a palavra era esperada (<code>esp</code>) ou inesperada (<code>inesp</code>);</p></li>
<li><p><code>resposta</code>, indicando se o participante acertou a pergunta mostrada ao fim do item experimental, o que garante que ele estaria prestanto atenção (acertou = <code>sim</code>, errou = <code>nao</code>).</p></li>
</ul>
<p><br></p>
<p><strong>Tarefa</strong></p>
<p>Para saber se a hipótese se confirmou,</p>
<ul>
<li>importe o conjunto de dados;</li>
<li>inspecione a distribuição dos tempos de resposta para a palavra crítica e elimine outliers e observações com tempo de resposta maior que 2000ms (cf. Fraundorf e Jaeger 2016);</li>
<li>transforme os dados se achar necessário;</li>
<li>construa um modelo linear misto para analisar se tipo de contexto, tipo de palavra e a interação entre esses fatores conseguem explicar a distribuição de dados;</li>
<li>faça análise por modelos aninhados se necessário.</li>
</ul>
<p>Não se esqueça de ir anotando o seu código para mostrar o que você está fazendo e justificar suas decisões. Ao final, escreva os resultados como se fosse um artigo.</p>
<p>Para saber mais sobre esse estudo, veja Godoy et al. (2017).</p>
<p></p>
<p></p>
<p></p>
</div>
</div>
<div id="modelos-lineares-mistos-contrastes-e-testes-post-hoc" class="section level1">
<h1><span class="header-section-number">4</span> Modelos lineares mistos: contrastes e testes post-hoc</h1>
<p>Nesta seção, aprenderemos a ajustar os contrastes de efeitos fixos para construir modelos mistos com interação entre fatores. Veremos que ajustar o tipo de contraste (<em>dummy</em> ou <em>sum</em>) é importante se quisermos fazer uma distinção entre efeitos simples e efeitos principais. Além disso, veremos como realizar análises <em>post-hoc</em> a partir do melhor modelo ajustado.</p>
<p>Antes de começar, baixe e carregue os pacotes necessários.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## instalar pacotes

<span class="kw">install.packages</span>(<span class="st">&quot;emmeans&quot;</span>)

## Carregar pacotes para a seção

<span class="kw">library</span>(lme4)
<span class="kw">library</span>(lmerTest)
<span class="kw">library</span>(ggplot2)
<span class="kw">library</span>(dplyr)

<span class="co"># o pacote emmeans será carregado posteriormente</span></code></pre></div>
<div id="tabela-de-coeficientes-em-mlms-com-interação" class="section level2">
<h2><span class="header-section-number">4.1</span> Tabela de coeficientes em MLMs com interação</h2>
<p>O conjunto de dados <code>priming2.csv</code> traz dados de uma simulação gerada para um experimento semelhante ao apresentado na Seção 3: um pesquisador fictício quis testar o efeito de <em>priming</em> no reconhecimento de palavras-alvo apresentadas após uma palavra prime com a qual havia ou não uma relação semântica. Além disso, o experimentador também controlou o SOA de apresentação, mas dessa vez o formato curto tinha um SOA de 250ms. Vamos importar e ver esses dados.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## importar conjunto de dados

priming2 &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;dados/priming2.csv&quot;</span>)

## inspecionar dados

<span class="kw">head</span>(priming2)
<span class="co">#&gt;      item participante       prime   SOA    tempo  resposta</span>
<span class="co">#&gt; 1 item_01         S_01 relacionado curto 961.1079   correct</span>
<span class="co">#&gt; 2 item_02         S_01 relacionado curto 687.9993   correct</span>
<span class="co">#&gt; 3 item_03         S_01 relacionado curto 819.4017 incorrect</span>
<span class="co">#&gt; 4 item_04         S_01 relacionado curto 786.8615   correct</span>
<span class="co">#&gt; 5 item_05         S_01 relacionado curto 943.5287   correct</span>
<span class="co">#&gt; 6 item_06         S_01 relacionado curto 682.6980 incorrect</span>

## conhecer variáveis

<span class="kw">str</span>(priming2)
<span class="co">#&gt; &#39;data.frame&#39;:    1200 obs. of  6 variables:</span>
<span class="co">#&gt;  $ item        : Factor w/ 60 levels &quot;item_01&quot;,&quot;item_02&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...</span>
<span class="co">#&gt;  $ participante: Factor w/ 20 levels &quot;S_01&quot;,&quot;S_02&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</span>
<span class="co">#&gt;  $ prime       : Factor w/ 2 levels &quot;nrelacionado&quot;,..: 2 2 2 2 2 2 2 2 2 2 ...</span>
<span class="co">#&gt;  $ SOA         : Factor w/ 2 levels &quot;curto&quot;,&quot;longo&quot;: 1 1 1 1 1 1 1 1 1 1 ...</span>
<span class="co">#&gt;  $ tempo       : num  961 688 819 787 944 ...</span>
<span class="co">#&gt;  $ resposta    : Factor w/ 2 levels &quot;correct&quot;,&quot;incorrect&quot;: 1 1 2 1 1 2 1 1 1 1 ...</span></code></pre></div>
<p>Os nomes das variáveis são os mesmos que já conhecemos. Vamos começar a análise pela inspeção e limpeza de dados.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Conferindo distribuição de dados

<span class="kw">ggplot</span>(priming2, <span class="kw">aes</span>(<span class="dt">sample =</span> tempo))+
<span class="st">  </span><span class="kw">stat_qq</span>()+
<span class="st">  </span><span class="kw">stat_qq_line</span>()+
<span class="st">  </span><span class="kw">facet_wrap</span>(~prime)</code></pre></div>
<p><img src="mlm_files/figure-html/priming2.1-1.png" width="480" /></p>
<p>Pelo gráfico acima, vimos que a distribuição de dados parece normal, exceto pelos valores que estão fora da nossa faixa estabelecida de 200ms a 1500ms. Como fizemos na Seção 3, excluímos os valores que consideramos <em>outliers</em>, conferimos a distribuição novamente e extraímos as médias para cada uma das condições para conhecermos melhor nosso conjunto de dados.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Selecionando apenas resposta cujo tempo esteja entre 200 ms e 1500 ms e que estejam 
## marcadas como correct para a variável resposta

priming2 =<span class="st"> </span>priming2%&gt;%
<span class="st">  </span><span class="kw">filter</span>(tempo &gt;<span class="st"> </span><span class="dv">200</span> &amp;<span class="st"> </span>tempo &lt;<span class="st"> </span><span class="dv">1500</span> &amp;<span class="st"> </span>resposta ==<span class="st"> &quot;correct&quot;</span>)

## Conferindo novamente a distribuição dos dados

<span class="kw">ggplot</span>(priming2, <span class="kw">aes</span>(<span class="dt">sample =</span> tempo))+
<span class="st">  </span><span class="kw">stat_qq</span>()+
<span class="st">  </span><span class="kw">stat_qq_line</span>()+
<span class="st">  </span><span class="kw">facet_wrap</span>(~prime)</code></pre></div>
<p><img src="mlm_files/figure-html/primingSOAlimpeza2-1.png" width="480" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Vendo a média (em ms) dos tempos de reação para as quatro condições

priming2%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(prime, SOA)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="kw">mean</span>(tempo))
<span class="co">#&gt; # A tibble: 4 x 3</span>
<span class="co">#&gt; # Groups:   prime [2]</span>
<span class="co">#&gt;   prime        SOA   `mean(tempo)`</span>
<span class="co">#&gt;   &lt;fct&gt;        &lt;fct&gt;         &lt;dbl&gt;</span>
<span class="co">#&gt; 1 nrelacionado curto          706.</span>
<span class="co">#&gt; 2 nrelacionado longo          710.</span>
<span class="co">#&gt; 3 relacionado  curto          694.</span>
<span class="co">#&gt; 4 relacionado  longo          643.</span></code></pre></div>
<p>Se quisermos (e é recomendável), podemos ver a distribuição por participante para identificar se há algum se comportando de forma anômala.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Conferindo distribuição de dados por participante

<span class="kw">ggplot</span>(priming2, <span class="kw">aes</span>(<span class="dt">sample =</span> tempo))+
<span class="st">  </span><span class="kw">stat_qq</span>()+
<span class="st">  </span><span class="kw">stat_qq_line</span>()+
<span class="st">  </span><span class="kw">facet_wrap</span>(~participante)</code></pre></div>
<p><img src="mlm_files/figure-html/participante2-1.png" width="528" /></p>
<p>Podemos agora construir nosso modelo linear misto para investigar se prime e SOA influenciam o tempo de resposta. Como aprendemos, primeiro tentamos criar o modelo com a arquitetura máxima de efeitos aleatórios, retirando <em>slopes</em> para resolver problemas de convergência.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## construção do modelo completo (erro de convergência)

model.full &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime*SOA +<span class="st"> </span>(<span class="dv">1</span>+prime*SOA|participante) +<span class="st"> </span>(<span class="dv">1</span>+prime*SOA|item), 
                   <span class="dt">data =</span> priming2, <span class="dt">REML=</span><span class="ot">FALSE</span>)
<span class="co">#&gt; Warning in checkConv(attr(opt, &quot;derivs&quot;), opt$par, ctrl = control$checkConv, :</span>
<span class="co">#&gt; Model failed to converge with max|grad| = 0.0158969 (tol = 0.002, component 1)</span>

## remoção de slopes para participante (erro de convergência)

model.full &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime*SOA +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>+prime*SOA|item), 
                   <span class="dt">data =</span> priming2, <span class="dt">REML=</span><span class="ot">FALSE</span>)
<span class="co">#&gt; Warning in checkConv(attr(opt, &quot;derivs&quot;), opt$par, ctrl = control$checkConv, :</span>
<span class="co">#&gt; unable to evaluate scaled gradient</span>
<span class="co">#&gt; Warning in checkConv(attr(opt, &quot;derivs&quot;), opt$par, ctrl = control$checkConv, :</span>
<span class="co">#&gt; Model failed to converge: degenerate Hessian with 1 negative eigenvalues</span>
<span class="co">#&gt; Warning: Model failed to converge with 1 negative eigenvalue: -2.6e-01</span>

## remoção de slopes para item

model.full &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime*SOA +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), 
                   <span class="dt">data =</span> priming2, <span class="dt">REML=</span><span class="ot">FALSE</span>)</code></pre></div>
<p>Conseguimos alcançar convergência com o terceiro modelo, que tem prime, SOA e a interação entre essas condições como efeitos fixos, além de interceptos aleatórios para participante e item. Comparamos esse modelo com o modelo aninhado <code>model.prime.SOA</code>. O resultado da comparação indica que a interação tem efeito significativo.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## modelo sem interação

model.prime.SOA &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime+SOA +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), 
                        <span class="dt">data =</span> priming2, <span class="dt">REML=</span><span class="ot">FALSE</span>)

## comparação por modelos aninhados

<span class="kw">anova</span>(model.full, model.prime.SOA)
<span class="co">#&gt; Data: priming2</span>
<span class="co">#&gt; Models:</span>
<span class="co">#&gt; model.prime.SOA: tempo ~ prime + SOA + (1 | participante) + (1 | item)</span>
<span class="co">#&gt; model.full: tempo ~ prime * SOA + (1 | participante) + (1 | item)</span>
<span class="co">#&gt;                 Df   AIC   BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)    </span>
<span class="co">#&gt; model.prime.SOA  6 14619 14649 -7303.3    14607                             </span>
<span class="co">#&gt; model.full       7 14604 14640 -7295.2    14590 16.189      1  5.734e-05 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>

## Resultado: interação é significativo</code></pre></div>
<p>Vamos dar uma olhada na tabela de coeficientes do modelo e compará-la com as médias de tempos de resposta por prime e por SOA, além de retomarmos as médias para cada uma das condições.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## média por prime

priming2%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(prime)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">media =</span> <span class="kw">mean</span>(tempo))
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   prime        media</span>
<span class="co">#&gt;   &lt;fct&gt;        &lt;dbl&gt;</span>
<span class="co">#&gt; 1 nrelacionado  708.</span>
<span class="co">#&gt; 2 relacionado   668.</span>
            
## média por SOA

priming2%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(SOA)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">media =</span> <span class="kw">mean</span>(tempo))
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   SOA   media</span>
<span class="co">#&gt;   &lt;fct&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 curto  700.</span>
<span class="co">#&gt; 2 longo  677.</span>

## média por prime x SOA

priming2%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(SOA, prime)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">media =</span> <span class="kw">mean</span>(tempo))%&gt;%
<span class="st">  </span><span class="kw">mutate_if</span>(is.numeric, format, <span class="dv">1</span>) ## retorna valores com 4 dígitos depois do ponto
<span class="co">#&gt; # A tibble: 4 x 3</span>
<span class="co">#&gt; # Groups:   SOA [2]</span>
<span class="co">#&gt;   SOA   prime        media   </span>
<span class="co">#&gt;   &lt;fct&gt; &lt;fct&gt;        &lt;chr&gt;   </span>
<span class="co">#&gt; 1 curto nrelacionado 706.2971</span>
<span class="co">#&gt; 2 curto relacionado  693.9389</span>
<span class="co">#&gt; 3 longo nrelacionado 710.2517</span>
<span class="co">#&gt; 4 longo relacionado  643.2373</span>

## coeficientes do modelo

<span class="kw">summary</span>(model.full)
<span class="co">#&gt; Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s</span>
<span class="co">#&gt;   method [lmerModLmerTest]</span>
<span class="co">#&gt; Formula: tempo ~ prime * SOA + (1 | participante) + (1 | item)</span>
<span class="co">#&gt;    Data: priming2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      AIC      BIC   logLik deviance df.resid </span>
<span class="co">#&gt;  14604.4  14639.9  -7295.2  14590.4     1159 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Scaled residuals: </span>
<span class="co">#&gt;     Min      1Q  Median      3Q     Max </span>
<span class="co">#&gt; -3.3611 -0.6517  0.0017  0.6681  5.1576 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Random effects:</span>
<span class="co">#&gt;  Groups       Name        Variance Std.Dev.</span>
<span class="co">#&gt;  item         (Intercept)   199     14.11  </span>
<span class="co">#&gt;  participante (Intercept)  5592     74.78  </span>
<span class="co">#&gt;  Residual                 14913    122.12  </span>
<span class="co">#&gt; Number of obs: 1166, groups:  item, 60; participante, 20</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Fixed effects:</span>
<span class="co">#&gt;                           Estimate Std. Error       df t value Pr(&gt;|t|)    </span>
<span class="co">#&gt; (Intercept)                705.983     18.258   25.958  38.668  &lt; 2e-16 ***</span>
<span class="co">#&gt; primerelacionado           -11.465     10.102 1089.326  -1.135    0.257    </span>
<span class="co">#&gt; SOAlongo                     5.699     10.102 1089.020   0.564    0.573    </span>
<span class="co">#&gt; primerelacionado:SOAlongo  -57.804     14.311 1089.750  -4.039 5.74e-05 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Correlation of Fixed Effects:</span>
<span class="co">#&gt;             (Intr) prmrlc SOAlng</span>
<span class="co">#&gt; primerelcnd -0.273              </span>
<span class="co">#&gt; SOAlongo    -0.273  0.494       </span>
<span class="co">#&gt; prmrlcn:SOA  0.193 -0.706 -0.706</span></code></pre></div>
<p>Para tentar entender os coeficientes, vamos olhar o intercepto do modelo. Nosso primeiro instinto seria achar que o intercepto corresponde à condição de prime não-relacionado. Contudo, o tempo de resposta médio para a condição de prime não-relacionado foi de 708ms. Se olharmos com atenção, veremos que o valor do intercepto diz respeito ao tempo médio da condição não-relacionado <em>quando o SOA é curto</em>.</p>
<p>Há uma pequena discrepância entre os valores da tabela gerada a partir de <code>summarise()</code> e os valores dos coeficientes que vemos aqui (706ms vs 705.98ms), mas isso se deve ao fato de os valores da tabela de coeficientes levarem em conta os efeitos aleatórios de participante e item. Outras pequenas discrepâncias aparecerão mais adiante.</p>
<p>Vamos preencher a <strong>Tabela 4.1</strong> com os valores médios de tempo de resposta que conseguimos descobrir através da tabela de coeficientes.</p>
<div align="center">
<table>
<thead>
<tr class="header">
<th align="right"></th>
<th align="right">nrelacionado</th>
<th align="right">relacionado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">curto</td>
<td align="right">705.9ms</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="right">longo</td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p><strong>Tabela 4.1:</strong> Valor do intercepto entre as quatro condições experimentais</p>
</div>
<p><br></p>
<p>Voltando aos coeficientes, vimos que o valor de <span class="math inline">\(\beta\)</span> para a linha <code>primerelacionado</code> é -11.465. Somando esse valor ao intercepto, chegamos ao valor do 694.51, que é próximo à média de tempo de resposta para a condição <code>relacionado+curto</code>. O que o p-valor dessa linha indica, então, é que a diferença entre as condições relacionado e não-relaciodo <em>quando o SOA é curto</em> não é significativa (p = 0.257). Preenchemos esse valor na <strong>Tabela 4.2</strong> e destacamos os valores que a linha <code>primerelacionado</code> está comparando.</p>
<p><br></p>
<div align="center">
<table>
<thead>
<tr class="header">
<th align="right"></th>
<th align="right">nrelacionado</th>
<th align="right">relacionado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">curto</td>
<td align="right"><strong>705.9ms</strong></td>
<td align="right"><strong>694.5ms</strong></td>
</tr>
<tr class="even">
<td align="right">longo</td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p><strong>Tabela 4.2:</strong> Comparação de valores do intercepto e da condição curto-relacionado</p>
</div>
<p><br></p>
<p>A próxima linha, <code>SOAlongo</code>, indica um <span class="math inline">\(\beta\)</span> de 5.699. Somado ao intercepto, temos 711.5ms, um valor próximo ao valor médio do tempo de reação da condição <code>nrelacionado+longo</code>. Vemos, portanto, que não há diferença significativa entre as condições de SOA <em>quando o prime é não-relacionado</em> (p = 0.573). Preenchemos esse valor na <strong>Tabela 4.2</strong> e destacamos a comparação feita pela linha <code>SOAlongo</code>.</p>
<p><br></p>
<div align="center">
<table>
<thead>
<tr class="header">
<th align="right"></th>
<th align="right">nrelacionado</th>
<th align="right">relacionado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">curto</td>
<td align="right"><strong>705.9ms</strong></td>
<td align="right">694.5ms</td>
</tr>
<tr class="even">
<td align="right">longo</td>
<td align="right"><strong>711.5ms</strong></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p><strong>Tabela 4.3:</strong> Comparação de valores do intercepto e da condição longo-nrelacionado</p>
</div>
<p><br></p>
<p>Por fim, a última linha tem um valor <span class="math inline">\(\beta\)</span> de -57.804, que somado ao intercepto resulta em 648 - valor aproximado ao indicado pela função <code>summarise()</code> para a condição <code>relacionado+longo</code> (mais uma vez, a diferença se deve ao fato de a tabela de coeficientes considerar efeitos aleatórios de participante e item). O p-valor dessa linha indica uma diferença significativa de reação entre <code>relacionado+longo</code> e <code>nrelacionado-curto</code> (p &lt; 0.0001). Com isso, preenchemos a <strong>Tabela 4.4</strong>, destacando a comparação feita pela linha <code>primerelacionado:SOAlongo</code>.</p>
<p><br></p>
<div align="center">
<table>
<thead>
<tr class="header">
<th align="right"></th>
<th align="right">nrelacionado</th>
<th align="right">relacionado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">curto</td>
<td align="right"><strong>705.9ms</strong></td>
<td align="right">694.5ms</td>
</tr>
<tr class="even">
<td align="right">longo</td>
<td align="right">711.5ms</td>
<td align="right"><strong>648ms</strong></td>
</tr>
</tbody>
</table>
<p><strong>Tabela 4.4:</strong> Comparação de valores do intercepto e da condição longo-relacionado</p>
</div>
<p><br></p>
<p>Como vimos, a tabela de coeficientes do modelo nos dá uma série de comparações. Cabe, agora, nos perguntarmos se elas são informativas. Vimos que o efeito de prime não é significativo quando o SOA é curto, mas será que é quando quando o SOA é longo? Ou, desconsiderando SOA, será que teríamos um efeito de prime? O efeito de SOA não foi significativo para a condição de prime não-relacionado, mas será que esse resultado se mantem quando para primes relacionados? Por fim, de que vale comparar o tempo de reação da condição prime não-relacionado de SOA curto com a condição de prime relacionado com SOA longo? Essa comparação se dá em níveis diferentes de cada uma das condições, e portanto não é informativa nem sobre os efeitos de prime, nem de SOA e nem da interação entre essas variáveis.</p>
</div>
<div id="efeito-simples-e-efeito-principal" class="section level2">
<h2><span class="header-section-number">4.2</span> Efeito simples e efeito principal</h2>
<p>Para entender a tabela de coeficientes que a função <code>lmer</code> constrói por <em>default</em>, precisamos primeiro entender a diferença entre efeito principal e efeito simples. Considere a a <strong>Tabela 4.5</strong>, que traz novamente a média de tempo de reação por condição e suas médias marginais. Para facilitar nossa explicação e conseguirmos generalizar para outras situações, estamos chamando a condição prime de A e a condição SOA de B.</p>
<p>A média marginal <span class="math inline">\(\mu_{B1}\)</span> de 700ms, por exemplo, indica o valor médio de tempo de resposta da condição <span class="math inline">\(B_1\)</span> ignorando os níveis da condição A (no caso de nosso experimento, a média dos itens de SOA curto, independente do tipo de prime). Testar o <strong>efeito principal</strong> de B é testar a hipótese nula de que <span class="math inline">\(\mu_{B1}\)</span> = <span class="math inline">\(\mu_{B2}\)</span>. Por outro lado, testar um <strong>efeito simples</strong> de B é testar o efeito de B <em>para um nível específico de A</em> - por exemplo, seria testar hipótese nula de que <span class="math inline">\(\mu_{A1.B1}\)</span> = <span class="math inline">\(\mu_{A1.B2}\)</span>.</p>
<p><br></p>
<div align="center">
<table>
<thead>
<tr class="header">
<th align="right"></th>
<th align="right">nrelacionado <span class="math inline">\((A_1)\)</span></th>
<th align="right">relacionado <span class="math inline">\((A_2)\)</span></th>
<th></th>
<th></th>
<th align="right"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">curto (<span class="math inline">\(B_1\)</span>)</td>
<td align="right"><span class="math inline">\(\mu_{A1.B1}\)</span> = 705.9ms</td>
<td align="right"><span class="math inline">\(\mu_{A2.B1}\)</span> = 694.5ms</td>
<td></td>
<td></td>
<td align="right"><span class="math inline">\(\mu_{B1}\)</span> = 700ms</td>
</tr>
<tr class="even">
<td align="right">longo (<span class="math inline">\(B_2\)</span>)</td>
<td align="right"><span class="math inline">\(\mu_{A1.B2}\)</span> = 711.5ms</td>
<td align="right"><span class="math inline">\(\mu_{A2.B2}\)</span> = 648.0ms</td>
<td></td>
<td></td>
<td align="right"><span class="math inline">\(\mu_{B2}\)</span> = 679ms</td>
</tr>
<tr class="odd">
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td></td>
<td></td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="right"></td>
<td align="right"><span class="math inline">\(\mu_{A1}\)</span> = 708.7ms</td>
<td align="right"><span class="math inline">\(\mu_{A2}\)</span> = 671.2ms</td>
<td></td>
<td></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p><strong>Tabela 4.5</strong>: médias e médias marginais de um experimento 2x2</p>
</div>
<p><br></p>
<p>Em seu post sobre contrastes e efeitos simples/principais<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>, Dale Barr resume a questão da seguinte maneira:</p>
<blockquote>
<p>Em um desenho AxB, o efeito simples de A é o efeito de A <strong>controlando</strong> B, equanto o efeito principal de A é o efeito de A <strong>ignorando</strong> B.</p>
</blockquote>
<p>Muitas vezes (pelo menos em experimentos na área da psicologia) estamos interessados em efeitos principais e sua interação. Testes como a ANOVA, por exemplo, já reportam os efeitos principais em seus resultados. Se é esse o nosso interesse, a tabela de coeficientes de um modelo linear é pouco útil ou informativa, pois mostra apenas efeitos simples. Isso acontece porque o intercepto do modelo é construído a partir de um tipo específico de contraste entre condições, definido por <em>default</em> nas funções de modelos lineares. Se quisermos que a tabela de coeficientes informe efeitos e interações principais, precisamos mudar explicitamente esse tipo de contraste.</p>
</div>
<div id="contrastes" class="section level2">
<h2><span class="header-section-number">4.3</span> Contrastes</h2>
<p>Quando estudamos a construção de um modelo linear na Seção 2, fizemos uma representação gráfica para mostrar que o modelo assume o nível de referência de uma variável como tendo valor igual a 0, e o nível subsequente com valor igual a 1. Vimos também que, ao assumir valor igual a 0, esse nível de referência assume o valor de intercepto. Esse tipo de <strong>contraste</strong> entre as variáveis pode ser chamada de <em>dummy coding</em> ou <em>treatment</em>, e é a codificação <em>default</em> dos modelos lineares. Podemos ver essa codificação pedindo para a função <code>contrasts()</code> nos mostrar o contraste entre as variáveis de <code>SOA</code> e <code>prime</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## conferindo sum coding para variável priming

<span class="kw">contrasts</span>(priming2$prime)
<span class="co">#&gt;              relacionado</span>
<span class="co">#&gt; nrelacionado           0</span>
<span class="co">#&gt; relacionado            1</span>

## conferindo sum coding para variável SOA

<span class="kw">contrasts</span>(priming2$SOA)
<span class="co">#&gt;       longo</span>
<span class="co">#&gt; curto     0</span>
<span class="co">#&gt; longo     1</span></code></pre></div>
<p>Para uma variável <code>A</code> com os níveis <span class="math inline">\(A_1\)</span> e <span class="math inline">\(A_2\)</span>, o <em>dummy coding</em> pode ser descrito pela <strong>Tabela 4.6</strong>.</p>
<p><br></p>
<div align="center">
<table>
<thead>
<tr class="header">
<th align="right"></th>
<th align="right"><em>dummy coding</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right"><span class="math inline">\(A_1\)</span></td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right"><span class="math inline">\(A_2\)</span></td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p><strong>Tabela 4.6:</strong> Dummy coding para condição com dois níveis</p>
</div>
<p><br></p>
<p>Recuperando aqui o que foi discutido na Seção 2 para modelos lineares com efeitos fixos categóricos, como gênero, podemos ver que o valor desse contraste é útil porque entra no cálculo do modelo linear. Na ocasião, vimos que 226.33 era o valor de <span class="math inline">\(\beta_0\)</span> (valor do coeficiente quando y é zero, que no caso correspondia ao gênero feminino). O valor <span class="math inline">\(x_1\)</span> tinha o valor de 1 porque vimos que o nível <code>masculino</code> foi assim codificado pelo modelo, e com esses valores conseguimos calcular a média do nível masculino.</p>
<blockquote>
<p><strong>Relembrando cálculo de y na regressão com uma variável</strong></p>
<p><span class="math inline">\(y=\beta_{0}+\beta_{1}x_{1}\)</span></p>
<p>Se quisermos calcular o valor de <code>y</code> para masculino (o nosso <span class="math inline">\(x_1\)</span>), podemos substituir essa equação pelo valores obtidos em nosso modelo linear:</p>
<p><span class="math inline">\(\beta_{0}\)</span> = 226.33</p>
<p><span class="math inline">\(\beta_{1}\)</span> = -98.33</p>
<p><span class="math inline">\(x_1\)</span> = 1</p>
<p>y = 226.33 + (-98.33*1) = 128</p>
</blockquote>
<p>A tabela de coeficientes de um modelo linear com contrastes do tipo <em>dummy</em> mostra resultados referentes aos efeitos simples das variáveis envolvidas. Quando nosso experimento tem apenas uma variável de 2 níveis, isso não é um problema: afinal, o objetivo último da análise será contrastar <span class="math inline">\(A_1\)</span> e <span class="math inline">\(A_2\)</span>. Contudo, como vimos com os resultados de <code>model.full</code>, isso pode ser um problema quando queremos reportar efeitos principais envolvendo mais de uma variável e suas interações.</p>
<p>Em um experimento 2x2, podemos usar o chamado <em>sum coding</em> (cf. <strong>Tabela 4.7</strong>) para opor dois níveis de uma variável. Dessa maneira, os resultados da tabela de coeficientes mostrarão efeitos principais para as variáveis testadas. Ao mudarmos o contraste para aplicar o <em>sum coding</em> a uma variável, opomos seus níveis usando os valores positivos e negativos, frequentemente 0.5 e -0.5, o que mudará o cálculo de <span class="math inline">\(\beta_0\)</span>. Nessa situação o <span class="math inline">\(\beta_0\)</span> deixará de corresponder a um dos níveis da variável e passará a corresponder ao valor médio geral das observações).</p>
<p><br></p>
<div align="center">
<table>
<thead>
<tr class="header">
<th align="right"></th>
<th align="right"><em>sum coding</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right"><span class="math inline">\(A_1\)</span></td>
<td align="right">-0.5</td>
</tr>
<tr class="even">
<td align="right"><span class="math inline">\(A_2\)</span></td>
<td align="right">0.5</td>
</tr>
</tbody>
</table>
<p><strong>Tabela 4.7:</strong> sum coding para condição com dois níveis</p>
</div>
<p><br></p>
<p>Para entendermos como isso é feito, vamos re-codificar nossas variáveis <code>prime</code> e <code>SOA</code>, rodar o modelo linear novamente e analisar os resultados.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## ajustando e conferindo sum coding para variável priming

<span class="kw">contrasts</span>(priming2$prime) =<span class="st"> </span><span class="kw">c</span>(-<span class="fl">0.5</span>, <span class="fl">0.5</span>)
<span class="kw">contrasts</span>(priming2$prime)
<span class="co">#&gt;              [,1]</span>
<span class="co">#&gt; nrelacionado -0.5</span>
<span class="co">#&gt; relacionado   0.5</span>

## ajustando e conferindo sum coding para variável SOA

<span class="kw">contrasts</span>(priming2$SOA) =<span class="st"> </span><span class="kw">c</span>(-<span class="fl">0.5</span>,<span class="fl">0.5</span>)
<span class="kw">contrasts</span>(priming2$SOA)
<span class="co">#&gt;       [,1]</span>
<span class="co">#&gt; curto -0.5</span>
<span class="co">#&gt; longo  0.5</span>

## ajustando novamente o modelo linear com os novos contrastes

model.full &lt;-<span class="st"> </span><span class="kw">lmer</span>(tempo ~<span class="st"> </span>prime*SOA +<span class="st"> </span>(<span class="dv">1</span>|participante) +<span class="st"> </span>(<span class="dv">1</span>|item), 
                   <span class="dt">data =</span> priming2, <span class="dt">REML=</span><span class="ot">FALSE</span>)

## resultado

<span class="kw">summary</span>(model.full)
<span class="co">#&gt; Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s</span>
<span class="co">#&gt;   method [lmerModLmerTest]</span>
<span class="co">#&gt; Formula: tempo ~ prime * SOA + (1 | participante) + (1 | item)</span>
<span class="co">#&gt;    Data: priming2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      AIC      BIC   logLik deviance df.resid </span>
<span class="co">#&gt;  14604.4  14639.9  -7295.2  14590.4     1159 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Scaled residuals: </span>
<span class="co">#&gt;     Min      1Q  Median      3Q     Max </span>
<span class="co">#&gt; -3.3611 -0.6517  0.0017  0.6681  5.1576 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Random effects:</span>
<span class="co">#&gt;  Groups       Name        Variance Std.Dev.</span>
<span class="co">#&gt;  item         (Intercept)   199     14.11  </span>
<span class="co">#&gt;  participante (Intercept)  5592     74.78  </span>
<span class="co">#&gt;  Residual                 14913    122.12  </span>
<span class="co">#&gt; Number of obs: 1166, groups:  item, 60; participante, 20</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Fixed effects:</span>
<span class="co">#&gt;             Estimate Std. Error       df t value Pr(&gt;|t|)    </span>
<span class="co">#&gt; (Intercept)  688.649     17.197   20.433  40.045  &lt; 2e-16 ***</span>
<span class="co">#&gt; prime1       -40.367      7.156 1089.950  -5.641 2.16e-08 ***</span>
<span class="co">#&gt; SOA1         -23.203      7.156 1089.947  -3.242  0.00122 ** </span>
<span class="co">#&gt; prime1:SOA1  -57.804     14.311 1089.750  -4.039 5.74e-05 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Correlation of Fixed Effects:</span>
<span class="co">#&gt;             (Intr) prime1 SOA1  </span>
<span class="co">#&gt; prime1       0.001              </span>
<span class="co">#&gt; SOA1         0.001 -0.009       </span>
<span class="co">#&gt; prime1:SOA1 -0.002  0.003  0.003</span></code></pre></div>
<p>Os valores da tabela de coeficiente agora são mais informativos. O intercepto agora corresponde ao tempo médio de resposta ignorando as condições experimentais (de novo há pequenas diferenças causadas pelo fato de o modelo considerar efeitos aleatórios de participantes e itens).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## média de tempo de resposta

<span class="kw">mean</span>(priming2$tempo)
<span class="co">#&gt; [1] 688.4222</span></code></pre></div>
<p>A linha <code>prime1</code> agora mostra o contraste que definimos entre os níveis das condições prime, e não a comparação direta com o intercepto. Vemos que o <span class="math inline">\(\beta\)</span> dessa linha é -40.367, próximo à diferença entre as condições de prime <em>ignorando o efeito de SOA</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## média por prime

priming2%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(prime)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">media =</span> <span class="kw">mean</span>(tempo))
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   prime        media</span>
<span class="co">#&gt;   &lt;fct&gt;        &lt;dbl&gt;</span>
<span class="co">#&gt; 1 nrelacionado  708.</span>
<span class="co">#&gt; 2 relacionado   668.</span>

## beta de prime1

<span class="dv">708</span> -<span class="st"> </span><span class="dv">668</span>
<span class="co">#&gt; [1] 40</span></code></pre></div>
<p>Similarmente, vemos que o <span class="math inline">\(\beta\)</span> de <code>SOA1</code> é -23.203. Essa é a diferença entre as condições de SOA <em>ignorando o efeito de prime</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## media por SOA

priming2%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(SOA)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">media =</span> <span class="kw">mean</span>(tempo))
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   SOA   media</span>
<span class="co">#&gt;   &lt;fct&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 curto  700.</span>
<span class="co">#&gt; 2 longo  677.</span>

## beta de SOA1

<span class="dv">700</span> -<span class="st"> </span><span class="dv">677</span>
<span class="co">#&gt; [1] 23</span></code></pre></div>
<p>Ou seja, a tabela de coeficientes agora informa os efeitos principais de prime e SOA, obtido através das médias marginais que indicamos na <strong>Tabela 4.5</strong>. Como a análise por modelos aninhados nos mostrou que houve interação significativa, convém ter cautela ao reportar esses efeitos principais, mas faremos isso ao criar análises post-hoc na seção seguinte. Por enquanto, vamos analisar a linha <code>prime1:SOA1</code>.</p>
<p>Dessa vez, essa linha está mostrando a diferença entre os níveis de prime para SOA curto e os níveis de prime para SOA longo. Confuso? Vamos fazer o cálculo na mão e veremos que temos um valor similar o <span class="math inline">\(\beta\)</span> da interação, que foi de -57.8.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## média por prime x SOA

priming2%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(SOA, prime)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">media =</span> <span class="kw">mean</span>(tempo))%&gt;%
<span class="st">  </span><span class="kw">mutate_if</span>(is.numeric, format, <span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 4 x 3</span>
<span class="co">#&gt; # Groups:   SOA [2]</span>
<span class="co">#&gt;   SOA   prime        media   </span>
<span class="co">#&gt;   &lt;fct&gt; &lt;fct&gt;        &lt;chr&gt;   </span>
<span class="co">#&gt; 1 curto nrelacionado 706.2971</span>
<span class="co">#&gt; 2 curto relacionado  693.9389</span>
<span class="co">#&gt; 3 longo nrelacionado 710.2517</span>
<span class="co">#&gt; 4 longo relacionado  643.2373</span>

## calculando diferenças

## SOAcurto nrelacionado - SOAcurto relacionado

efeito.curto =<span class="st"> </span><span class="fl">706.2971</span> -<span class="st"> </span><span class="fl">693.9389</span>

## SOAlongo nrelacionado - SOAlongo relacionado

efeito.longo =<span class="st"> </span><span class="fl">710.2517</span> -<span class="st"> </span><span class="fl">643.2373</span>

## Diferença entre os valores

efeito.curto -<span class="st"> </span>efeito.longo
<span class="co">#&gt; [1] -54.6562</span></code></pre></div>
<p>Existem outras maneiras de codificar contrastes e elas vão depender (a) da natureza de seus dados; (b) de que tipo de informação você quer extrair deles; (c) do número de níveis que você tem para uma variável. Aqui vamos apenas tratar de casos de experimentos 2x2 para situações em que queremos extrair informação sobre efeitos principais. Se esse não for o seu caso, não se esqueça de estudar qual a melhor maneira de codificar suas variáveis<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>.</p>
<div id="tarefa-contrastes-e-modelos" class="section level4">
<h4><span class="header-section-number">4.3.0.1</span> Tarefa: contrastes e modelos</h4>
<p>Antes de continuarmos, vamos fazer uma pausa e ver se você agora consegue entender um pouco melhor a descrição da seção de análise de alguns artigos. Leia o trecho abaixo e responda:</p>
<ul>
<li>Que tipo de contraste os autores usaram para os efeitos fixos?</li>
<li>Como seria a equação do modelo ajustado?</li>
</ul>
<blockquote>
<p><strong>Modelo 1</strong></p>
<p><em>“The response variable was the rate of the coherence relations; aspect was the only fixed effect, and it was contrasted using treatment coding to allow for a direct comparison between perfective and imperfective contexts. The model included random intercepts for participants and items, and random slopes for aspect.”</em> (Godoy et al. 2018)</p>
</blockquote>
<blockquote>
<p><strong>Modelo 2</strong></p>
<p><em>“The results were statistically analyzed using generalized (binomial) mixed-effects models with crossed random effects for subjects and items (Baayen et al., 2008). The predictors PROSODIC STRESS (noun stress vs. quantifier stress) and CONTEXT (alternative type present vs. alternative type absent) were sum-coded (as 0.5 and -0.5) and used as fixed predictors, along with their interaction; random effects of these three parameters were also fit for items (Barr et al., 2013), but not for subjects, since each subject had too few trials to fit this complex structure well.”</em> (Chen et al. 2018)</p>
</blockquote>
</div>
</div>
<div id="análises-post-hoc" class="section level2">
<h2><span class="header-section-number">4.4</span> Análises <em>post-hoc</em></h2>
<p>A tabela de coeficientes nos informa que há efeito de prime, SOA e interação. Contudo, não sabemos que efeitos são esses. Como SOA afetou prime? Será que o efeito de prime só se fez sentir nas condições de SOA longo? Ou será que se fez presente nas duas condições, mas com um efeito muito maior nas condições de SOA longo?</p>
<p>Essas são perguntas que só posso me fazer <em>depois</em> de realizar a análise inicial dos dados. Como os testes que preciso fazer para responder a essas perguntas são pensados apenas depois dessa análise inicial que já fizemos, chamamo-os de <strong>testes <em>post-hoc</em></strong>.</p>
<p>No caso de nosso experimento, uma análise <em>post-hoc</em> deverá comparar par-a-par as condições experimentais para identificar onde e como houve o efeito de interação entre <em>prime</em> e SOA. O pacote para análises <em>post-hoc</em> de modelos lineares se chama <code>emmeans</code>. Vamos carregar o pacote.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## carregar emmeans

<span class="kw">library</span>(emmeans)</code></pre></div>
<p>Vamos fazer a análise com a função <code>emmeans()</code> e salvar o resultado em um objeto de nome <code>post.hoc</code>. Ao fazermos essa análise, especificamos o modelo a partir do qual a análise é feita (<code>model.full</code>) e indicamos que queremos as comparações considerando os níveis de <em>prime</em>, <em>SOA</em> e sua interação (<code>~ prime*SOA</code>). Depois, usamos a função <code>pairs</code> para extrair a comparação por pares de <code>post.hoc</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## análise post-hoc

post.hoc =<span class="st"> </span><span class="kw">emmeans</span>(model.full, ~<span class="st"> </span>prime*SOA)

## visualização dos pares da análise post-hoc

<span class="kw">pairs</span>(post.hoc, <span class="dt">adjust=</span><span class="st">&quot;tukey&quot;</span>)
<span class="co">#&gt;  contrast                                estimate   SE   df t.ratio p.value</span>
<span class="co">#&gt;  nrelacionado,curto - relacionado,curto      11.5 10.1 1089  1.135  0.6680 </span>
<span class="co">#&gt;  nrelacionado,curto - nrelacionado,longo     -5.7 10.1 1089 -0.564  0.9427 </span>
<span class="co">#&gt;  nrelacionado,curto - relacionado,longo      63.6 10.1 1089  6.310  &lt;.0001 </span>
<span class="co">#&gt;  relacionado,curto - nrelacionado,longo     -17.2 10.2 1091 -1.688  0.3303 </span>
<span class="co">#&gt;  relacionado,curto - relacionado,longo       52.1 10.1 1091  5.140  &lt;.0001 </span>
<span class="co">#&gt;  nrelacionado,longo - relacionado,longo      69.3 10.1 1090  6.833  &lt;.0001 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Degrees-of-freedom method: satterthwaite </span>
<span class="co">#&gt; P value adjustment: tukey method for comparing a family of 4 estimates</span></code></pre></div>
<p>O resultado mostra seis comparações resultantes de análises par-a-par, bem como os p-valores associados. Você deve ter percebido que especificamos <code>adjust = &quot;tukey&quot;</code> na sintaxe para extração das comparações pareadas. O que esse ajuste faz é corrigir o p-valor dessas comparações.</p>
<p>Imagine que você tem um saco com 20 bolinhas: 19 pretas e uma vermelha. Qual a probabilidade de tirar uma bolinha vermelha ao pegar uma bolinha qualquer desse saco? A probabilidade é de 1/20, ou 0.05. Agora imagine que você repetiu essa operação 10 vezes. Quanto mais você repete essa operação, maior a chance de você pegar essa bolinha vermelha <em>ao menos uma vez</em>. A lógica da <strong>correção do p-valor</strong> é mais ou menos essa. Há uma chance de um efeito significativo ser, na verdade, um <strong>falso positivo</strong>: ele está em nossos dados, mas se deu ao acaso e não por causa das variáveis que estamos controlando. Quanto mais testes de hipóteses fazemos, maior a chance de termos um falso positivo. Por isso, sempre que fazemos testes de múltiplas comparações, é importante corrigir o p-valor. Há outros métodos de correção, mas Tukey costuma ser o mais usado na psicologia. Como vimos, é bem simples aplicá-lo na sintaxe de <code>emmeans</code>.</p>
<p>Olhando os resultados, vemos que não houve diferença de tipo de prime quando o SOA era curto (primeira linha). No entanto, a condição de prime relacionado e SOA longo teve tempo de resposta significativamente maior comparado a todas as outras condições (linhas 3, 5 e 6). Esses dados indicam que o efeito de prime se faz sentir apenas quando o SOA é longo.</p>
</div>
<div id="prática-contrastes-e-testes-post-hoc" class="section level2">
<h2><span class="header-section-number">4.5</span> Prática: contrastes e testes post-hoc</h2>
<p>O conjunto de dados <code>proindef.cvs</code> traz um subconjunto dos dados de Godoy (2014).</p>
<p>Nesse experimento de leitura autocadenciada, a autora testou a influência do tipo de pronome - plural ou singular - e do tipo de referência - correferencial ou indefinida - no tempo de leitura de expressões pronominais. Abaixo, há um exemplo de itens experimentais usados (as sentenças estão pela metade):</p>
<p><br></p>
<ol style="list-style-type: decimal">
<li><strong>Pronome singular em relação de co-referência:</strong></li>
</ol>
<p>Ângelo trabalha como secretário e <strong>ele</strong> geralmente…</p>
<ol start="2" style="list-style-type: decimal">
<li><strong>Pronome plural em relação de co-referência:</strong></li>
</ol>
<p>Ângelo e Chico trabalhavam como secretários e <strong>eles</strong> geralmente…</p>
<ol start="3" style="list-style-type: decimal">
<li><strong>Pronome singular em relação de referência indefinida:</strong></li>
</ol>
<p>Na escola do bairro, Rebeca trabalha como secretária e <strong>ele</strong> geralmente…</p>
<ol start="4" style="list-style-type: decimal">
<li><strong>Pronome plural em relação de referência indefinida:</strong></li>
</ol>
<p>Na escola do bairro, Rebeca trabalhava como secretária e <strong>eles</strong> geralmente…</p>
<p>Nas sentenças (1) e (2), os pronomes destacados são co-referentes, respectivamente, a “Ângelo” e “Ângelo e Chico”. Em (3) e (4), os mesmos pronomes não tem qualquer referente definido na sentença anterior, mas é possível inferir um referente através da expressão “Na escola do bairro”.</p>
<p>A hipótese de Godoy (2014) era de que pronomes singulares dão início à busca por um co-referente sempre que encontrados, enquanto pronomes plurais instanciam uma leitura indefinida na falta de um referente. Portanto os tempos de leitura do pronome na condição (1), (2) e (4) seriam iguais, enquanto o pronome em (3) geraria um tempo de leitura maior pela quebra de co-referência.</p>
<p>Como pronomes são palavras muito pequenas, é normal o efeito esperado ocorrer na palavra seguinte da sentença (esse efeito é chamado de <em>spill-over</em>). No experimento em questão, essa palavra era sempre um advérbio, e o seu tempo de leitura está salvo na planilha <code>proindef.cvs</code>.</p>
<p>O conjunto de dados têm 5 colunas:</p>
<ul>
<li><p><code>cod</code>, com identificação dos 42 sentenças experimentais;</p></li>
<li><p><code>participante</code>, com identificação dos participantes da pesquisa;</p></li>
<li><p><code>pronome</code>, com indicação de pronome plural (<code>p</code>) ou singular (<code>s</code>);</p></li>
<li><p><code>referencia</code>, com indicação de referência co-referencial (<code>cor</code>) ou <code>indefinida</code> (<code>ind</code>);</p></li>
<li><p><code>tempo.adverbio</code>, com o tempo de leitura do adverbio.</p></li>
</ul>
<p><br></p>
<p><strong>Tarefa</strong></p>
<p>Para saber se a hipótese se confirmou,</p>
<ul>
<li>importe o conjunto de dados;</li>
<li>filtre apenas as observações em que os participantes acertaram a pergunta feita sobre o item experimental;</li>
<li>inspecione a distribuição dos tempos de resposta para a palavra crítica e elimine outliers e observações com tempo de resposta maior que 2000ms;</li>
<li>transforme os dados se achar necessário;</li>
<li>ajuste o contraste mais adequado para a análise;</li>
<li>construa um modelo linear misto para analisar se tipo de pronome, tipo de referência e a interação entre esses fatores conseguem explicar a distribuição de dados;</li>
<li>faça análise por modelos aninhados se necessário;</li>
<li>faça análises post-hoc se necessário;</li>
<li>faça análise dos resíduos.</li>
</ul>
<p>Não se esqueça de ir anotando o seu código para mostrar o que você está fazendo e justificar suas decisões. Ao final, escreva os resultados como se fosse um artigo.</p>
<blockquote>
<p><strong>Importante!</strong> As análises que vamos fazer aqui são bem diferentes daquelas apresentadas em Godoy (2014), ainda que as conclusões sejam as mesmas. No estudo original, há um terceiro nível para a variável pronome.</p>
</blockquote>
<p></p>
<p></p>
<p></p>
</div>
</div>
<div id="modelos-lineares-generalizados-mistos" class="section level1">
<h1><span class="header-section-number">5</span> Modelos lineares generalizados mistos</h1>
<p>Nesta seção, vamos aprender a fazer análise em dados categóricos binários por meio de modelos lineares generalizados mistos. Para isso, falaremos brevemente sobre a distribuição binomial e nos deteremos na relação entre <em>probabilidade</em>, <em>odds</em> e <em>log-odds</em>. Isso nos ajudará a entender a tabela de coeficientes de modelos lineares generalizados para dados em distribuição binomial.</p>
<p>Antes de começar, carregue os pacotes que serão usados na seção.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Carregar pacotes para a seção

<span class="kw">library</span>(lme4)
<span class="kw">library</span>(lmerTest)
<span class="kw">library</span>(ggplot2)
<span class="kw">library</span>(dplyr)</code></pre></div>
<div id="a-distribuição-binomial" class="section level2">
<h2><span class="header-section-number">5.1</span> A distribuição binomial</h2>
<p>Até o momento, vimos casos de experimentos e análises em que a variável resposta era uma medida numérica e contínua. No entanto, são várias as situações em que um pesquisador precisa criar modelos em que a variável dependente é de natureza categórica, como gênero, cidade, faixa etária, classe social etc., e gera distribuições diferentes da distribuição normal. Dentre as distribuições possíveis para dados categóricos, a <strong>distribuição binomial</strong> é uma das mais comuns.</p>
<p>A distribuição binomial é aplicada para calcular as probablidades de sucesso de um evento que tenha apenas dois resultados possíveis. Eventos desse tipo seriam tirar cara ou coroa, ter olho castanho ou não-castanho, errar ou acertar uma questão, comprar um item ou não comprar um item, clicar numa propaganda ou não clicar numa propaganda etc. Podemos usar uma distribuição binomial para modelar o resultado desses eventos quando:</p>
<ul>
<li><p>só há dois resultados possíveis a cada tentativa;</p></li>
<li><p>todas as tentativas são independentes das demais;</p></li>
<li><p>a probabilidade de sucesso permanece inalterada em toda tentativa.</p></li>
</ul>
<p>Um bom exemplo de fenômeno que pode ser descrito por uma binomial é a probabilidade de tirar cara em <em>n</em> lançamentos de moeda. A cada nova tentativa, minha probabilidade de tirar cara permanece em 0.5, e o fato de eu ter tirado cara em um lance anterior não muda esse fato. Não poderíamos dizer o mesmo para a probabilidade de tirar uma bola vermelha de dentro de uma caixa com 10 bolas vermelhas e 10 bolas pretas. Inicialmente, minha probabilidade de tirar uma bola vermelha é de 0.5. Se eu tirar uma bola preta <em>sem devolvê-la para caixa</em>, minha probabilidade de tirar vermelha muda: é agora de 10/19, ou 0.52. A cada lance, minha probabilidade de tirar uma bola vermelha é alterada a depender das tentativas anteriores.</p>
<p>Nesta seção, vamos aprender a analisar dados em distribuição binomial a partir de regressão logística. Se você não se sente seguro sobre a definição de uma binomial, faça uma pausa no tutorial e estude um pouco o assunto. Caso contrário, podemos começar discutindo</p>
</div>
<div id="probabilidades-e-chances-odds" class="section level2">
<h2><span class="header-section-number">5.2</span> Probabilidades e chances (<em>odds</em>)</h2>
<p>Na literatura, é comum que dados em distribuição binomial sejam analisados por meio de um teste chamado <code>qui-quadrado</code> (ou <code>chi-square</code>, em inglês). No entanto, dados de experimentos ou observações que trazem medidas repetidas por participantes, itens ou outros fatores não são adequadamente tratados por esse tipo de teste. Por esse motivo, nesses casos é preferível fazer uma <strong>regressão logística</strong>. Para entender o que é a regressão logística, primeiro precisamos entender os conceitos de <strong>probabilidade</strong> e <strong>chance</strong> (ou <em>odds</em>, em inglês).</p>
<p>Vamos imaginar que eu apostei no lançamento de uma moeda de cara ou coroa. Se eu tirar coroa, eu ganho. Se eu tirar cara, eu perco. Perceba que o resultado desse experimento me dá uma distribuição binominal: meus resultados podem ser codificados em termos de sucesso e fracasso, e cada lançamento de moeda gera um resultado independente dos demais.</p>
<p>Imagine que jogamos as moedas 100 vezes. Eu tive 50 sucessos (coroa) e 50 fracassos (cara). As três afirmações abaixo descrevem, de maneiras diferentes, esse resultado.</p>
<blockquote>
<ol style="list-style-type: lower-alpha">
<li>A chance de sair coroa é de 1:1 (um para um - uma coroa para cada cara)</li>
<li>A chance de sair coroa é de 50%</li>
<li>A probabilidade de sair coroa é de 0.5 (50 em 100, ou 50/100)</li>
</ol>
</blockquote>
<p>Vamos continuar jogando a nossa moeda imaginária. Dessa vez, eu joguei a moeda algumas vezes e tive 1 sucesso (coroa) e 10 fracassos (cara). Pelo menos uma das informações abaixo está incorreta. Tente corrigir antes de ver a resposta.</p>
<blockquote>
<ol style="list-style-type: lower-alpha">
<li>a chance de sair coroa é de 1:10 (1 para 10).</li>
<li>a chance, em porcentagem, de sair coroa é de 10%.</li>
<li>a probabilidade de sair coroa é de 0.1.</li>
</ol>
</blockquote>
<p><br></p>
<p>Se eu tive 10 sucessos e 1 fracasso, significa que eu joguei a moeda 11 vezes. Portanto, é correto afirmar que minha chance de sucesso é de 1:10 (1 sucesso a cada 10 fracassos). Contudo, as outras informações estão erradas. Essa chance é de 9%, se eu quiser falar em termos de porcentagem, e a probabilidade de sucesso foi de 0.09.</p>
<p>Voltemos à moeda. Agora joguei a moeda 100 vezes e tive 64 sucessos (coroa) e 36 fracassos (cara). Podemos fazer as seguiintes afirmações:</p>
<blockquote>
<ol style="list-style-type: lower-alpha">
<li>a razão da chance (ou <strong>odds ratio</strong>, em inglês) de sair coroa é de 64:36 ou 32:18 ou 16:9 (a cada 16 coroas, saem 9 caras) ou 1.77 (para cada cara, sai 1.77 coroas)</li>
</ol>
</blockquote>
<blockquote>
<ol start="2" style="list-style-type: lower-alpha">
<li>a probabilidade de sair coroa é de 0.64 (a cada 100 jogadas, saem 64 coroas (64/100))</li>
</ol>
</blockquote>
<p>A <strong>Tabela 5.1</strong> expressa a relação entre porcentagem, chance e probabilidade.</p>
<div align="center">
<table>
<thead>
<tr class="header">
<th align="right">Porcentagem</th>
<th align="right">Probabilidade</th>
<th align="right">Chances (sucesso:fracasso)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">50%</td>
<td align="right">0.5</td>
<td align="right">1:1 ou 1</td>
</tr>
<tr class="even">
<td align="right">10%</td>
<td align="right">0.1</td>
<td align="right">1:9 ou 0.11</td>
</tr>
<tr class="odd">
<td align="right">90%</td>
<td align="right">0.9</td>
<td align="right">9:1 ou 9</td>
</tr>
<tr class="even">
<td align="right">75%</td>
<td align="right">0.75</td>
<td align="right">3:1 ou 3</td>
</tr>
<tr class="odd">
<td align="right">80%</td>
<td align="right">0.8</td>
<td align="right">8:2 ou 4:1 ou 4</td>
</tr>
</tbody>
</table>
<p><strong>Tabela 5.1:</strong> Relação entre porcentagem, probabilidade e chance</p>
</div>
<p><br></p>
<p><strong>Odds</strong> (ou chances) é só uma outra maneira de expressar probabilidades. Você já deve ter ouvido isso na mídia, quando dizem algo como <em>“estudos indicam que quem consome produto X tem 10 vezes mais chances de desenvolver câncer”</em>. Esse tipo de frase reporta uma chance de 10 para 1 (10:1).</p>
<p>Quando comparamos a chance de sucesso entre dois grupos, A e B, um teste estatístico vai tentar responder as seguintes perguntas:</p>
<blockquote>
<p><em>A chance de sucesso no grupo A aumenta ou diminuiu em relação ao grupo B? Em quantas vezes? Essa mudança é significativamente diferente de 0?</em></p>
</blockquote>
<p>Aqui começamos a ver a relação entre uma análise que pretende analisar dados em distribuição binomial e as noções de <em>probabilidade</em> ou <em>chance</em>. Afinal, se essas são duas maneiras de expressar o resultado de um experimento cuja variável resposta tem distribuição binomial, qual dessas medidas deve entrar como variável resposta em um modelo estatístico? Há outras medidas possíveis?</p>
<p>Vamos ver a resposta a essas perguntas mais adiante, mas por enquanto é bom ter em mente algumas propriedades sobre os valores possíveis de chance e probabilidade. Enquanto os valores de probabilidade se limitam entre 0 e 1, os valores da razão entre chances de sucesso e fracasso (odds ratio) tem um valor de 0 a infinito:</p>
<p><br></p>
<p><strong>Valores de probabilidade:</strong> 0 a 1</p>
<p><strong>Valores de Odds Ratio:</strong> 0 a infinito</p>
<p><br></p>
<p>Agora que já conhecemos a noção de <strong>odds</strong> (começaremos a usar essa nomenclatura daqui em diante), vamos entender como utilizá-la para analisar um conjunto de dados e qual sua relação com a regressão logística.</p>
</div>
<div id="regressão-logística-e-log-odds" class="section level2">
<h2><span class="header-section-number">5.3</span> Regressão logística e <em>log-odds</em></h2>
<p>A regressão logística analisa se a chance de sucesso de um grupo A é diferente da chance de sucesso do grupo B; ou seja: requer uma variável resposta categórica. Ilustremos com um subconjunto dos dados do estudo de Godoy et al. (2018), que já conhecemos na tarefa prática da Seção 1.</p>
<p>Relembremos que uma das hipóteses desse estudo era a de que a interpretação do pronome ambíguo das sentenças (1) e (2) seria influenciada pelo aspecto perfectivo (“passou”) ou imperfectivo (“estava passando”) do verbo da sentença anterior. A probabilidade de escolher o referente no papel temático de alvo (e.g. Rubens) seria maior em (1) que em (2).</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>Augusto passou a bola para Rubens. Ele…</li>
<li>Augusto estava passando a bola para Rubens. Ele…</li>
</ol>
</blockquote>
<p>Para testar essa hipótese, os autores criaram sentenças semelhantes a essas e pediram para os participantes criarem continuações. Depois, analisaram as respostas para identificar se a interpretação do pronome retomava a fonte (como Augusto) ou o alvo (Rubens) e anotaram essas respostas numa planilha que você pode acessar importando o conjunto de dados <code>pronomes.csv</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## importar conjunto de dados

pronome =<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;dados/pronome.csv&quot;</span>)

## inspecionar conjunto de dados

<span class="kw">head</span>(pronome)
<span class="co">#&gt;   participante item                                                     frase</span>
<span class="co">#&gt; 1           MC    n Mônica estava transferindo o dinheiro para Letícia. Ela..</span>
<span class="co">#&gt; 2          JFF    n Mônica estava transferindo o dinheiro para Letícia. Ela..</span>
<span class="co">#&gt; 3         BPLB    n Mônica estava transferindo o dinheiro para Letícia. Ela..</span>
<span class="co">#&gt; 4         NAME    n Mônica estava transferindo o dinheiro para Letícia. Ela..</span>
<span class="co">#&gt; 5          M C    n Mônica estava transferindo o dinheiro para Letícia. Ela..</span>
<span class="co">#&gt; 6           MA    n Mônica estava transferindo o dinheiro para Letícia. Ela..</span>
<span class="co">#&gt;        aspecto classe interpretacao</span>
<span class="co">#&gt; 1 imperfective     C3       ambiguo</span>
<span class="co">#&gt; 2 imperfective     C3         fonte</span>
<span class="co">#&gt; 3 imperfective     C3         fonte</span>
<span class="co">#&gt; 4 imperfective     C3         fonte</span>
<span class="co">#&gt; 5 imperfective     C3         fonte</span>
<span class="co">#&gt; 6 imperfective     C3         fonte</span>

## inspecionar conjunto de dados 2

<span class="kw">str</span>(pronome)
<span class="co">#&gt; &#39;data.frame&#39;:    569 obs. of  6 variables:</span>
<span class="co">#&gt;  $ participante : Factor w/ 48 levels &quot;ACBO&quot;,&quot;B A S&quot;,..: 33 19 4 40 30 31 45 12 33 19 ...</span>
<span class="co">#&gt;  $ item         : Factor w/ 12 levels &quot;b&quot;,&quot;d&quot;,&quot;f&quot;,&quot;g&quot;,..: 9 9 9 9 9 9 9 9 5 5 ...</span>
<span class="co">#&gt;  $ frase        : Factor w/ 25 levels &quot;Beatriz encaminhou o ofício para Laura. Ela..&quot;,..: 18 18 18 18 18 18 18 18 10 10 ...</span>
<span class="co">#&gt;  $ aspecto      : Factor w/ 2 levels &quot;imperfective&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</span>
<span class="co">#&gt;  $ classe       : Factor w/ 2 levels &quot;C1&quot;,&quot;C3&quot;: 2 2 2 2 2 2 2 2 2 2 ...</span>
<span class="co">#&gt;  $ interpretacao: Factor w/ 3 levels &quot;alvo&quot;,&quot;ambiguo&quot;,..: 2 3 3 3 3 3 3 3 3 1 ...</span></code></pre></div>
<p>O conjunto de dados contém 6 colunas:</p>
<blockquote>
<p><code>participante</code>, com identificação dos participantes da pesquisa;</p>
</blockquote>
<blockquote>
<p><code>item</code>, com identificação de 16 histórias utilizadas como itens experimentais;</p>
</blockquote>
<blockquote>
<p><code>frase</code>, com as frases utilizadas no experimento;</p>
</blockquote>
<blockquote>
<p><code>aspecto</code>, com identificação das condições de aspecto verbal: perfectivo (<code>perfective</code>) e imperfectivo (<code>imperfective</code>);</p>
</blockquote>
<blockquote>
<p><code>classe</code>, uma condição experimental que entenderemos depois;</p>
</blockquote>
<blockquote>
<p><code>interpretacao</code>: interpretação do pronome tal qual anotado pelos pesquisadores, e que indica interpretação de fonte (<code>fonte</code>), alvo (<code>alvo</code>) ou ambígua (<code>ambiguo</code>).</p>
</blockquote>
<p><br></p>
<p>Antes de analisar os dados de interpretação de pronomes, precisamos excluir os dados de leitura ambígua dos pronomes. São aqueles casos em que a resposta dos participantes não deixava claro quem era o referente do pronome.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## filtragem para considerar apenas casos suja resposta tenha sido alvo ou fonte

pronome =<span class="st"> </span>pronome%&gt;%
<span class="st">  </span><span class="kw">filter</span>(interpretacao ==<span class="st"> &quot;alvo&quot;</span> |<span class="st"> </span>interpretacao ==<span class="st"> &quot;fonte&quot;</span>)%&gt;%
<span class="st">  </span><span class="kw">droplevels</span>()</code></pre></div>
<p>Vamos usar o <code>dplyr</code> para ver quantas interpretações de <code>fonte</code> e <code>alvo</code> temos para os aspectos perfectivo e imperfectivo.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## tabela com contagem de pronome por aspecto

pronome%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(aspecto, interpretacao)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">n =</span> <span class="kw">n</span>())
<span class="co">#&gt; # A tibble: 4 x 3</span>
<span class="co">#&gt; # Groups:   aspecto [2]</span>
<span class="co">#&gt;   aspecto      interpretacao     n</span>
<span class="co">#&gt;   &lt;fct&gt;        &lt;fct&gt;         &lt;int&gt;</span>
<span class="co">#&gt; 1 imperfective alvo             85</span>
<span class="co">#&gt; 2 imperfective fonte           174</span>
<span class="co">#&gt; 3 perfective   alvo            161</span>
<span class="co">#&gt; 4 perfective   fonte           107</span>

## tabela com frequência relativa de pronome por aspecto

pronome%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(aspecto, interpretacao)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">n =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">freq =</span> n /<span class="st"> </span><span class="kw">sum</span>(n))
<span class="co">#&gt; # A tibble: 4 x 4</span>
<span class="co">#&gt; # Groups:   aspecto [2]</span>
<span class="co">#&gt;   aspecto      interpretacao     n  freq</span>
<span class="co">#&gt;   &lt;fct&gt;        &lt;fct&gt;         &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 imperfective alvo             85 0.328</span>
<span class="co">#&gt; 2 imperfective fonte           174 0.672</span>
<span class="co">#&gt; 3 perfective   alvo            161 0.601</span>
<span class="co">#&gt; 4 perfective   fonte           107 0.399</span></code></pre></div>
<p><br></p>
<p>Comparemos esses valores aos valores em <em>odds</em> da <strong>Tabela 5.2</strong>.</p>
<p><br></p>
<div align="center">
<table>
<thead>
<tr class="header">
<th align="right">Aspecto</th>
<th align="right">Odds (fonte:alvo)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">imperfectivo</td>
<td align="right">174:85 ou 2.04</td>
</tr>
<tr class="even">
<td align="right">perfectivo</td>
<td align="right">107:161 ou 0.66</td>
</tr>
</tbody>
</table>
<p><strong>Tabela 5.2:</strong> <em>Odds ratio</em> por aspecto</p>
</div>
<p><br></p>
<p>Os resultados indicam que, de fato, uma interpretação de fonte tem maior chance de ocorrer após uma sentença no imperfectivo do que no perfectivo. Podemos ver isso no gráfico abaixo.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## gráfico da relação entre aspecto x interpretação

pronome%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(aspecto, interpretacao)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">n =</span> <span class="kw">n</span>())%&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">frequencia =</span> n /<span class="st"> </span><span class="kw">sum</span>(n))%&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(<span class="dt">x =</span> aspecto, <span class="dt">y=</span> frequencia, <span class="dt">fill =</span> interpretacao))+
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels=</span>scales::percent)+
<span class="st">  </span><span class="kw">geom_col</span>(<span class="dt">position =</span> <span class="st">&quot;dodge&quot;</span>)+
<span class="st">  </span><span class="kw">theme_bw</span>()</code></pre></div>
<p><img src="mlm_files/figure-html/plot-1.png" width="480" /></p>
<p><br></p>
<p>Vamos ajustar um modelo de regressão logística simples. A função que usamos é <code>glm()</code>, porque uma regressão logística é um <strong>modelo linear generalizado</strong>. Os modelos lineares generalizados conseguem lidar com dados de inúmeras famílias de distribuição. A sintaxe é a mesma que vimos em tutoriais anteriores:</p>
<div align="center">
<blockquote>
<p>interpretacao ~ aspecto</p>
</blockquote>
</div>
<p>Como temos apenas um efeito fixo - aspecto - e esse efeito tem apenas dois níveis (imperfectivo e perfectivo), vamos usar o contraste <em>dummy</em>. Isso nos permitirá uma comparação direta entre os níveis <span class="math inline">\(A_1\)</span> e <span class="math inline">\(A_2\)</span> do efeito que estamos analisando. No código abaixo, além de informarmos a equação, dizemos que nossa variável resposta é uma <em>binomial</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## criando um modelo linear generalizado

modelo.aspecto =<span class="st"> </span><span class="kw">glm</span>(interpretacao ~<span class="st"> </span>aspecto, pronome, <span class="dt">family =</span> binomial)

## vendo o resultado do modelo

<span class="kw">summary</span>(modelo.aspecto)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; glm(formula = interpretacao ~ aspecto, family = binomial, data = pronome)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Deviance Residuals: </span>
<span class="co">#&gt;     Min       1Q   Median       3Q      Max  </span>
<span class="co">#&gt; -1.4928  -1.0095   0.8919   0.8919   1.3551  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt;                   Estimate Std. Error z value Pr(&gt;|z|)    </span>
<span class="co">#&gt; (Intercept)         0.7164     0.1323   5.414 6.17e-08 ***</span>
<span class="co">#&gt; aspectoperfective  -1.1250     0.1818  -6.186 6.16e-10 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; (Dispersion parameter for binomial family taken to be 1)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     Null deviance: 728.25  on 526  degrees of freedom</span>
<span class="co">#&gt; Residual deviance: 688.41  on 525  degrees of freedom</span>
<span class="co">#&gt; AIC: 692.41</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Number of Fisher Scoring iterations: 4</span></code></pre></div>
<p>Vamos começar tentando entender o que os valores dos coeficientes querem dizer.</p>
<p>O <em>output</em> é similar ao que vimos para modelos lineares. Após o objeto <code>call</code> repetindo a fórmula do modelo, temos os resíduos e, então, os coeficientes. Aqui, entendemos que o aspecto imperfectivo está no lugar de intercepto. Isso significa que o modelo está comparando, em sua segunda linha, a distribuição da interpretação do pronome no perfectivo com o imperfectivo. Isso era esperado, já que usamos <em>dummy coding</em>. Mas o que os valores de <span class="math inline">\(\beta\)</span> querem dizer? Vamos começar com o <span class="math inline">\(\beta\)</span> do intercepto.</p>
<p>Em primeiro lugar, é importante saber o que o teste reporta sobre a interpretação do pronome. <strong>A regressão compara a proporção de uso do nível de não-referência com o nível de referência.</strong> Parece confuso? Vamos dar uma olhada em quais são os níveis da nossa variável resposta.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## consultando níveis e o valor de referência

<span class="kw">levels</span>(pronome$interpretacao)
<span class="co">#&gt; [1] &quot;alvo&quot;  &quot;fonte&quot;</span></code></pre></div>
<p><br></p>
<p>O comando <code>levels()</code> nos indica que o primeiro nível (o valor de referência) é <code>alvo</code> (porque o R segue ordem alfabética e numérica, e <code>alvo</code> vem antes de <code>fonte</code> por esse critério). No intercepto, a regressão está comparando, portanto, as taxas de fonte com as taxas do nível de referência, que é alvo, para o aspecto imperfectivo. Isso é exatamente o que fizemos quando falamos de <em>odds</em> - <code>sucesso:fracasso</code>.</p>
<p>Vamos dar uma olhada nos valores do coeficiente mais uma vez. Veja que o valor de <span class="math inline">\(\beta\)</span> no intercept é positivo: 0.716404.</p>
<div align="center">
<table>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Estimate
</th>
<th style="text-align:right;">
Std. Error
</th>
<th style="text-align:right;">
z value
</th>
<th style="text-align:right;">
Pr(&gt;|z|)
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:right;">
0.716404
</td>
<td style="text-align:right;">
0.1323323
</td>
<td style="text-align:right;">
5.413677
</td>
<td style="text-align:right;">
1e-07
</td>
</tr>
<tr>
<td style="text-align:left;">
aspectoperfective
</td>
<td style="text-align:right;">
-1.124980
</td>
<td style="text-align:right;">
0.1818483
</td>
<td style="text-align:right;">
-6.186363
</td>
<td style="text-align:right;">
0e+00
</td>
</tr>
</tbody>
</table>
<p><strong>Tabela 5.3:</strong> Coeficientes da regressão logística <code>interpretação ~ aspecto</code></p>
</div>
<p><br></p>
<p>Isso significa que, no intercepto (que aqui é o aspecto imperfectivo), há mais ocorrências de fonte do que alvo (o valor de referência), algo que já sabíamos pelo gráfico que fizemos antes. Mais que isso, vemos que a diferença entre as taxas de fonte e alvo é significativa (veja o p-valor associado ao <span class="math inline">\(\beta\)</span> do intercepto).</p>
<p>Mas por que 0.716404? De onde veio esse valor? Afinal, vimos que a proporção <code>fonte:alvo</code> para imperfectivo era 174:85, ou seja, 2.04 (cf. <strong>Tabela 5.2</strong>).</p>
<p>Em vez de reportar a <em>odds ratio</em> de fonte frente a alvo para sentenças de aspecto imperfectivo, o modelo linear usa o logaritmo desse valor. Vamos ver qual é o logaritmo de 174:85:</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## calculando o logarítimo da chance fonte:alvo para aspecto imperfectivo

<span class="kw">log</span>(<span class="dv">174</span>/<span class="dv">85</span>)
<span class="co">#&gt; [1] 0.716404</span></code></pre></div>
<p><br></p>
<p>Ou seja, o resultado do seu modelo está informando que a taxa de interpretação de fonte é de 2.047 para cada interpretação de alvo no aspecto imperfectivo. A única diferença é que ele está fazendo isso de uma forma um pouco mais complicada. Mas por quê?</p>
<p>O logaritmo da <em>odds ratio</em>, ou <strong><em>log-odds</em></strong> tem a vantagem de ser um número que pode assumir valores negativos; dessa maneira, podemos saber o sentido da diferença entre as taxas de sucesso e fracasso. Se o valor é positivo, houve mais sucessos que fracassos; se o valor é negativo, ocorreu o inverso.</p>
<p>Para mostrar porque isso é interessante, vejamos uma tabela que mostra os valores de <em>odds</em> <code>fonte:alvo</code> para o subconjunto de dados de Godoy et al. que estamos analisando e também para um experimento fictício chamado <em>Upsideworld</em>, que teria exatamente os valores opostos. Também mostramos um experimento hipotético em que não há diferença entre as taxas de ocorrência de alvo e fonte.</p>
<div align="center">
<table>
<thead>
<tr class="header">
<th align="right">Aspecto</th>
<th align="right">Odds Ratio Fonte:Alvo</th>
<th align="right">Log odds</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">Imperfectivo Godoy et al.</td>
<td align="right">174:85 ou 2.047</td>
<td align="right">0.716404</td>
</tr>
<tr class="even">
<td align="right">Perfectivo Godoy et al.</td>
<td align="right">107:161 ou 0.664</td>
<td align="right">-0.4085755</td>
</tr>
<tr class="odd">
<td align="right">Experimento hipotético</td>
<td align="right">100:100 ou 1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">Imperfectivo Upsideworld</td>
<td align="right">85:174 ou 0.488</td>
<td align="right">-0.716404</td>
</tr>
<tr class="odd">
<td align="right">Perfectivo Upsideworld</td>
<td align="right">161:107 ou 1.504</td>
<td align="right">0.4085755</td>
</tr>
</tbody>
</table>
<p><strong>Tabela 5.4:</strong> <em>Odds ratio</em> e <em>log odds</em> por aspecto</p>
</div>
<p><br></p>
<p>A <strong>Tabela 5.4</strong> mostra uma propriedade interessante dos <em>log-odds</em>: quando você inverte a proporção de sucesso e fracasso, o valor de <em>log-odds</em> permanece o mesmo, alterando apenas o seu sinal positivo ou negativo.</p>
<p>Voltemos a uma pergunta que fizemos no início desta seção:</p>
<blockquote>
<p>Se probabilidade e chance são duas maneiras de expressar o resultado de um experimento cuja variável resposta tem distribuição binomial, qual dessas medidas deve entrar como variável resposta em um modelo estatístico? Há outras medidas possíveis?</p>
</blockquote>
<p>Percebemos, então, que a regressão logística faz sua análise considerando o <strong>valor logarítimico da chance</strong>, ou, como se costuma chamar, <strong><em>log-odds</em></strong> ou <strong><em>logit</em></strong>, e o motivo disso é simples: esse valor permite uma relação de equivalência de valor absoluto entre as chances de <code>Sucesso:Fracasso</code> e <code>Fracasso:Sucesso</code>, e a direção do efeito é indicada pelo sinal positivo ou negativo.</p>
<p>Por fim, se você tem o valor de <em>log-odds</em> do intercepto, é possível calcular o seu <em>odds ratio</em> usando a função exponencial. Veja:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## calculando a chance (odds ratio) de fonte:alvo para imperfectivo a partir 
## da função exponencial

<span class="kw">exp</span>(<span class="fl">0.716404</span>)
<span class="co">#&gt; [1] 2.047059</span></code></pre></div>
<p>Temos aqui o valor da <em>odds ratio</em> para fonte no aspecto imperfectivo, que já havíamos visto que era de 2.047059!</p>
<p>Repetimos novamente a <strong>Tabela 5.3</strong> com os coeficientes do modelo.</p>
<div align="center">
<table>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Estimate
</th>
<th style="text-align:right;">
Std. Error
</th>
<th style="text-align:right;">
z value
</th>
<th style="text-align:right;">
Pr(&gt;|z|)
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:right;">
0.716404
</td>
<td style="text-align:right;">
0.1323323
</td>
<td style="text-align:right;">
5.413677
</td>
<td style="text-align:right;">
1e-07
</td>
</tr>
<tr>
<td style="text-align:left;">
aspectoperfective
</td>
<td style="text-align:right;">
-1.124980
</td>
<td style="text-align:right;">
0.1818483
</td>
<td style="text-align:right;">
-6.186363
</td>
<td style="text-align:right;">
0e+00
</td>
</tr>
</tbody>
</table>
<p><strong>Tabela 5.3:</strong> Coeficientes da regressão logística <code>interpretação ~ aspecto</code></p>
</div>
<p><br></p>
<p>Os valores dados para o aspecto perfectivo, na segunda linha, não corresponde ao seu <em>log-odd</em>, que é de -0.4085755. Por quê?</p>
<p>Lembremos que, em um modelo linear, a tabela de coeficientes dá os valores em relação ao intercepto. Assim, o modelo nos informa que, com relação ao aspecto imperfectivo, o <em>log-odd</em> de fonte de do aspecto perfectivo é de -1.124980. Esse valor negativo já nos indica que a chance de ocorrência de uma interpretação de fonte no aspecto perfectivo é <strong>menor</strong> que no aspecto imperfectivo, algo que já sabíamos ao ver o gráfico de distribuição dos dados. Além disso, o p-valor desse coeficiente nos mostra que essa diferença entre aspectos é significativa dado um <span class="math inline">\(\alpha\)</span> de 0.05.</p>
<p>A questão é: quão menor é a chance de uma leitura de fonte no aspecto perfectivo em comparação ao intercepto? Para saber, basta fazer a conversão do coeficiente - dado em <em>log-odds</em> - usando a função exponencial.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## calculando a chance de fonte:alvo no perfectivo em comparação ao intercept

<span class="kw">exp</span>(-<span class="fl">1.124980</span>)
<span class="co">#&gt; [1] 0.324659</span>

## calculando a chance de alvo:fonte no perfectivo em comparação ao intercept

<span class="kw">exp</span>(<span class="fl">1.124980</span>)
<span class="co">#&gt; [1] 3.080155</span></code></pre></div>
<p>O primeiro código nos diz que os participantes produziam 0.3 interpretação de fonte no aspecto perfectivo para cada interpretação de fonte no aspecto imperfectivo. Confuso, né? Fica mais fácil trocar o sinal e dizer que <strong>para cada leitura de fonte no aspecto perfectivo, havia cerca de três leituras de fonte no imperfectivo</strong>.</p>
</div>
<div id="modelos-lineares-generalizados-mistos-mlgms" class="section level2">
<h2><span class="header-section-number">5.4</span> Modelos Lineares Generalizados Mistos (MLGMs)</h2>
<p>Como vimos, a regressão logística é um tipo de modelo linear generalizado. Essa classe de modelos lida com variáveis respostas que não têm uma distribuição normal. Contudo, você deve ter notado um problema no modelo que usamos até aqui: ele desconsidera medidas repetidas por participante e item.</p>
<p>Já discutimos no tutorial anterior a importância de considerar cada participante e cada item como efeitos que introduzem uma variabilidade aleatória que deve estar prevista no modelo de análise. A equação de um modelo linear generalizado misto que considere interceptos e slopes aleatórios por itens e participantes é a mesma que ajustamos para modelos lineares mistos. Você vê essa equação abaixo.</p>
<blockquote>
<p>interpretacao ~ aspecto + (1+aspecto|pronome) + (1+aspecto|item)</p>
</blockquote>
<p>A implementação no <code>R</code> também não é muito diferente. Precisamos usar o pacote <code>lme4</code>, que permite lidar com efeitos aleatórios, mas dessa vez usamos a função <code>glmer()</code>. Como no caso da função <code>lmer()</code>, inserimos a sintaxe com efeitos fixos e aleatórios e o conjunto de dados.</p>
<p>Adicionalmente, informamos que a distribuição do nosso conjunto de dados pertence à família binomial. Informamos ainda que tipo de algoritmo otimizador queremos usar (esse tipo de especificação é útil para controlar problemas de convergência em modelos lineares generalizados, e no caso de regressão logística costuma-se usar o <code>bobyqa</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## construindo um MLGM com interceptos aleatórios por item e participantes e slopes 
## aleatórios por aspecto para item e participante (problema de convergência)

modelomisto.aspecto =<span class="st"> </span><span class="kw">glmer</span>(interpretacao ~<span class="st"> </span>aspecto +<span class="st"> </span>
<span class="st">                      </span>(<span class="dv">1</span>+aspecto|item) +<span class="st"> </span>(<span class="dv">1</span>+aspecto|participante), 
                      <span class="dt">data=</span>pronome, <span class="dt">family=</span><span class="kw">binomial</span>(<span class="dt">link=</span><span class="st">&quot;logit&quot;</span>),
                      <span class="dt">control =</span> <span class="kw">glmerControl</span>(<span class="dt">optimizer =</span> <span class="st">&quot;bobyqa&quot;</span>))

## retirando slope de aspecto por item (problema de convergência)

modelomisto.aspecto =<span class="st"> </span><span class="kw">glmer</span>(interpretacao ~<span class="st"> </span>aspecto +
<span class="st">                      </span>(<span class="dv">1</span>+aspecto|item) +<span class="st"> </span>(<span class="dv">1</span>|participante),
                      <span class="dt">data=</span>pronome, <span class="dt">family=</span><span class="kw">binomial</span>(<span class="dt">link=</span><span class="st">&quot;logit&quot;</span>),
                      <span class="dt">control =</span> <span class="kw">glmerControl</span>(<span class="dt">optimizer =</span> <span class="st">&quot;bobyqa&quot;</span>))

## retirando slope de aspecto por participante (problema de convergência)

modelomisto.aspecto =<span class="st"> </span><span class="kw">glmer</span>(interpretacao ~<span class="st"> </span>aspecto +<span class="st"> </span>
<span class="st">                      </span>(<span class="dv">1</span>+aspecto|item) +<span class="st"> </span>(<span class="dv">1</span>|participante),
                      <span class="dt">data=</span>pronome, <span class="dt">family=</span><span class="kw">binomial</span>(<span class="dt">link=</span><span class="st">&quot;logit&quot;</span>), 
                      <span class="dt">control =</span> <span class="kw">glmerControl</span>(<span class="dt">optimizer =</span> <span class="st">&quot;bobyqa&quot;</span>))

## retirando slope de aspecto por item

modelomisto.aspecto =<span class="st"> </span><span class="kw">glmer</span>(interpretacao ~<span class="st"> </span>aspecto +<span class="st"> </span>(<span class="dv">1</span>|item) +
<span class="st">                      </span>(<span class="dv">1</span>|participante), <span class="dt">data=</span>pronome, 
                      <span class="dt">family=</span><span class="kw">binomial</span>(<span class="dt">link=</span><span class="st">&quot;logit&quot;</span>), 
                      <span class="dt">control =</span> <span class="kw">glmerControl</span>(<span class="dt">optimizer =</span> <span class="st">&quot;bobyqa&quot;</span>))

## resultado do MLGM

<span class="kw">summary</span>(modelomisto.aspecto)
<span class="co">#&gt; Generalized linear mixed model fit by maximum likelihood (Laplace</span>
<span class="co">#&gt;   Approximation) [glmerMod]</span>
<span class="co">#&gt;  Family: binomial  ( logit )</span>
<span class="co">#&gt; Formula: interpretacao ~ aspecto + (1 | item) + (1 | participante)</span>
<span class="co">#&gt;    Data: pronome</span>
<span class="co">#&gt; Control: glmerControl(optimizer = &quot;bobyqa&quot;)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      AIC      BIC   logLik deviance df.resid </span>
<span class="co">#&gt;    588.7    605.8   -290.3    580.7      523 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Scaled residuals: </span>
<span class="co">#&gt;     Min      1Q  Median      3Q     Max </span>
<span class="co">#&gt; -3.0007 -0.5828  0.1853  0.5807  5.7836 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Random effects:</span>
<span class="co">#&gt;  Groups       Name        Variance Std.Dev.</span>
<span class="co">#&gt;  participante (Intercept) 2.072    1.440   </span>
<span class="co">#&gt;  item         (Intercept) 1.001    1.001   </span>
<span class="co">#&gt; Number of obs: 527, groups:  participante, 48; item, 12</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Fixed effects:</span>
<span class="co">#&gt;                   Estimate Std. Error z value Pr(&gt;|z|)    </span>
<span class="co">#&gt; (Intercept)         1.1341     0.3991   2.841  0.00449 ** </span>
<span class="co">#&gt; aspectoperfective  -1.7215     0.2484  -6.930 4.21e-12 ***</span>
<span class="co">#&gt; ---</span>
<span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Correlation of Fixed Effects:</span>
<span class="co">#&gt;             (Intr)</span>
<span class="co">#&gt; aspctprfctv -0.347</span></code></pre></div>
<p>Comparando o modelo que temos agora com o que fizemos anteriormente, vemos que os valores dos coeficientes do intercepto e do perfectivo em relação ao intercepto não são os mesmos. Isso é esperado, pois esse último modelo levou em conta a variabilidade por item e sujeito para calcular esses valores.</p>
<blockquote>
<p><strong>Atenção!</strong> O primeiro modelo que fizemos seria inadequado para o conjunto de dados que temos em mãos, pois ignorava efeitos aleatórios. Nós o construímos para fins didáticos, apenas para ensinar as diferenças entre <em>odds</em> e <em>log-odds</em>. Se seus dados são resultado de medidas repetidas por itens e participantes, use um modelo misto!</p>
</blockquote>
<p>Como vimos nas seções anteriores, a análise por modelos mistos se faz por comparação de modelos aninhados. Desse modo, construímos o <code>modelomisto.null</code>, cuja única diferença do <code>modelomisto.aspecto</code> é <strong>não</strong> contar com a condição <code>aspecto</code> como efeito fixo. Na sequência, comparamos os modelos.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## modelo sem aspecto como efeito fixo 

modelomisto.null =<span class="st"> </span><span class="kw">glmer</span>(interpretacao ~<span class="st"> </span><span class="dv">1</span> +<span class="st"> </span>(<span class="dv">1</span>|item) +<span class="st"> </span>(<span class="dv">1</span>+aspecto|participante), 
                    <span class="dt">data=</span>pronome, <span class="dt">family=</span><span class="kw">binomial</span>(<span class="dt">link=</span><span class="st">&quot;logit&quot;</span>),
                    <span class="dt">control =</span> <span class="kw">glmerControl</span>(<span class="dt">optimizer =</span> <span class="st">&quot;bobyqa&quot;</span>))

## comparação de modelos

<span class="kw">anova</span>(modelomisto.aspecto, modelomisto.null)
<span class="co">#&gt; Data: pronome</span>
<span class="co">#&gt; Models:</span>
<span class="co">#&gt; modelomisto.aspecto: interpretacao ~ aspecto + (1 | item) + (1 | participante)</span>
<span class="co">#&gt; modelomisto.null: interpretacao ~ 1 + (1 | item) + (1 + aspecto | participante)</span>
<span class="co">#&gt;                     Df    AIC    BIC  logLik deviance Chisq Chi Df Pr(&gt;Chisq)</span>
<span class="co">#&gt; modelomisto.aspecto  4 588.69 605.76 -290.35   580.69                        </span>
<span class="co">#&gt; modelomisto.null     5 630.39 651.72 -310.19   620.39     0      1          1</span></code></pre></div>
<p>A comparação de modelos nos mostra (sem nenhuma surpresa) que há diferença significativa entre os modelos, e, portanto, aspecto é uma variável que influencia a distribuição dos dados. Podemos reportar nossos resultados da seguinte maneira:</p>
<blockquote>
<p>“Ajustamos uma regressão logística com interpretação do pronome como variável resposta, aspecto como efeito fixo e interceptos aleatórios para participantes e itens. O contraste dos níveis do efeito fixo (perfectivo e imperfectivo) foi feito por meio de <em>dummy coding</em>, com <code>alvo</code> como nível de referência. Uma comparação por modelos aninhados indicou que aspecto contribui significativamente para o modelo (<span class="math inline">\(\chi^2\)</span> = 39.741, p &lt; 0.0001)”. O melhor modelo ajustado indica que a probabilidade de uma interpretação de fonte é menor para o aspecto perfectivo comparado ao aspecto imperfectivo (<span class="math inline">\(\beta\)</span> = -1.792, p &lt; 0.0001)</p>
</blockquote>
<p>Como não estamos lidando com modelos lineares, mas sim com modelos lineares generalizados, não é correto analisar os resíduos do melhor modelo ajustado a partir das mesmas hipóteses. Até o momento, o diagnóstico de modelos lineares generalizados é um tópico em aberto na pesquisa estatística. Diversos autores já propuseram maneiras de avaliar os resíduos desse tipo de modelo (Cordeiro e Demétrio, 2008; Paula, 2013); entretanto, implementações computacionais desses métodos ainda não estão disponíveis.</p>
</div>
<div id="modelos-lineares-generalizados-outras-distribuições" class="section level2">
<h2><span class="header-section-number">5.5</span> Modelos lineares generalizados: outras distribuições</h2>
<p>Como esse é um tutorial introdutório, ao falarmos de modelos lineares generalizados mistos nos limitamos apenas ao caso específico da regressão logística, usada para tratar de dados em distribuição binomial. No entanto, a função <code>glmer()</code> foi construída para lidar com outras famílias de distribuição. Consultando a documentação da função <code>family</code>, vemos listadas as seguintes opções:</p>
<ul>
<li>binomial</li>
<li>gaussiana (normal)</li>
<li>gama</li>
<li>gaussiana inversa (normal inversa)</li>
<li>poisson</li>
<li>quasibinomial</li>
<li>quasipoisson</li>
</ul>
<p>Além disso, há pacotes variados que lidam com outras distribuições não listadas acima. Podemos citar como exemplo o pacote <code>glmmTB</code>, que lida, dentre outras, com poisson-truncada, ou o pacote <code>ordinal</code>, que ajusta modelos mistos de regressão para dados de natureza ordinal.</p>
<p>Se você seguiu esse tutorial até aqui e não viu nenhum tipo de distribuição próxima das que está acostumado a usar em seu trabalho, procure se informar sobre que distribuições estão mais próximas dos fenômenos que você estuda e busque quais pacotes têm funções para lidar com elas. A comunidade <em>online</em> de usuários de <code>R</code> é bastante ativa, principalmente em fóruns como o <em>Stats Exchange</em><a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> (para dúvidas mais ligadas a estatística) e o Stack Overflow <a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> (mais voltado para dúvidas sobre programação). Independente do tipo de distribuição, tudo o que vimos ao longo desse tutorial em relação à sintaxe de efeitos fixos, aleatórios e à leitura de contraste de coeficientes se aplica no ajuste de outros tipos de MLMG.</p>
</div>
<div id="prática-modelos-lineares-generalizados" class="section level2">
<h2><span class="header-section-number">5.6</span> Prática: modelos lineares generalizados</h2>
<p>Os dados de Godoy et al. (2018) trazem uma coluna de que não tratamos até agora: <code>classe</code>. Os verbos selecionados para criar as frases do experimento se dividiam em três classes, mas aqui temos apenas duas delas:</p>
<p><strong>Classe 1</strong></p>
<p>Transferência de posse do objeto garantida e participantes da ação obrigatoriamente presentes na cena.</p>
<p>Exemplos:</p>
<pre><code>      - João trouxe a camisa para Luís. Ele...

      - Raul entregou a caneta para Júlio. Ele...
      
      - Rodrigo serviu a torta para Caio. Ele...</code></pre>
<p><strong>Classe 3</strong></p>
<p>Transferência de posse do objeto não está necessariamente garantida e não há obrigatoriedade de presença dos dois participantes da ação na mesma cena</p>
<p>Exemplos:</p>
<pre><code>      - Carol enviou o email para Cláudia. Ela...

      - Mônica transferiu o dinheiro para Letícia. Ela...
      
      - Heitor repassou a mensagem para Diego. Ele...</code></pre>
<p>A hipótese dos autores era de que os pronomes ambíguos teriam mais chance de fazer referência à fonte em verbos de Classe 3 que para verbos de Classe 1. Isso ocorreria porque o alvo (aquele que recebe o objeto) não precisaria estar presente na representação mental do evento de verbos de Classe 3.</p>
<p><strong>Tarefa</strong></p>
<ul>
<li><p>Faça uma análise completa dos dados para investigar se classe, aspecto e a interação entre esses fatores influenciam na interpretação do pronome.</p></li>
<li><p>Ao conduzir sua análise, siga todos os passos que você seguiria para a análise de dados.</p></li>
</ul>
</div>
</div>
<div id="referências" class="section level1 unnumbered">
<h1>Referências</h1>
<p>Barr, D. J., Levy, R., Scheepers, C., and Tily, H. J. (2013). Random effects structure for confirmatory hypothesis testing: Keep it maximal. J. Mem. Lang. 68, 255–278. doi: 10.1016/j.jml.2012.11.001</p>
<p>Baayen, R. H., Davidson, D. J., &amp; Bates, D. M. (2008). Mixed-effects modeling with crossed random effects for subjects and items. Journal of memory and language, 59(4), 390-412.</p>
<p>Chen I-H, Huang C-R and Politzer-Ahles S (2018) Determining the Types of Contrasts: The Influences of Prosody on Pragmatic Inferences. Front. Psychol. 9:2110. doi: 10.3389/fpsyg.2018.02110.</p>
<p>Clark, H. H. (1973). The language-as-fixed-effect fallacy: A critique of language statistics in psychological research. Journal of Verbal Learning and Verbal Behavior, 12, 335–359.</p>
<p>Cordeiro, G. M., &amp; Demétrio, C. G. B. (2008). Modelos lineares generalizados e extensões. Piracicaba: USP.</p>
<p>Enochson K, Culbertson J (2015) Collecting Psycholinguistic Response Time Data Using Amazon Mechanical Turk. PLoS ONE 10(3): e0116946. <a href="doi:10.1371/journal.pone.0116946" class="uri">doi:10.1371/journal.pone.0116946</a></p>
<p>Fraundorf, S. H., &amp; Jaeger, T. F. (2016). Readers generalize adaptation to newly-encountered dialectal structures to other unfamiliar structures. Journal of Memory and Language, 91, 28–58. <a href="https://doi.org/10.1016/j.jml.2016.05.006" class="uri">https://doi.org/10.1016/j.jml.2016.05.006</a></p>
<p>Godoy, M. C., Nunes, M. A. (em preparação). Uma comparação entre ANOVA e modelos lineares mistos para análise de dados de tempo de reação.</p>
<p>Godoy, M. C.; Weissheimer, J. ; Mafra, M. A. (2018) When Grammar Meets Pragmatics: Subject Preference and Coherence Relations in Brazilian Portuguese Pronoun Interpretation. Journal of Portuguese Linguistics, v. 17, p. 17, doi: 10.5334/jpl.197.</p>
<p>Godoy, M.C., Vieira, C. B., Andrade, G. L., Souza-Filho, N., Nunes, M. A. (2017) O papel do conhecimento de eventos no processamento de sentenças isoladas. Revista Letrônica, v. 10, n. 2, p. 538-554.</p>
<p>Godoy, M. C. (2014) Processamento de pronomes plurais não anafóricos. Revista Linguística, v. 10, p. 175-192.</p>
<p>Lo, S,; Andrews S. (2015) To transform or not to transform: using generalized linear mixed models to analyse reaction time data. Front. Psychol. 6:1171. doi: 10.3389/fpsyg.2015.01171</p>
<p>Paula, G. Modelos de regressão com apoio computacional. IME-USP.</p>
<p>Schmalz, X., Robidoux, S., Castles, A., Coltheart, M., Marinus, E. (preprint): German and English bodies: No evidence for cross-linguistic differences in preferred grain size.</p>
<p>Winter, B. (2013). Linear models and linear mixed effects models in R with linguistic applications.<br />
arXiv:1308.5499. [<a href="http://arxiv.org/pdf/1308.5499.pdf" class="uri">http://arxiv.org/pdf/1308.5499.pdf</a>]</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Veja uma discussão sobre o tema em <a href="https://www.theatlantic.com/science/archive/2018/11/psychologys-replication-crisis-real/576223/" class="uri">https://www.theatlantic.com/science/archive/2018/11/psychologys-replication-crisis-real/576223/</a>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Veja uma discussão sobre o tema em <a href="https://www.psychologicalscience.org/observer/preregistration-becoming-the-norm-in-psychological-science" class="uri">https://www.psychologicalscience.org/observer/preregistration-becoming-the-norm-in-psychological-science</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Uma boa explicação pode ser achada em <a href="http://www.portalaction.com.br/estatistica-basica/31-boxplot" class="uri">http://www.portalaction.com.br/estatistica-basica/31-boxplot</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Segundo Godoy e Nunes (submetido), “REML é a sigla, em inglês, para <em>REstricted Maximum Likelihood</em>. É uma técnica utilizada no ajuste de modelos lineares mistos para a estimação de parâmetros perturbadores. Os parâmetros perturbadores não são o objetivo final da análise, mas devem ser levados em conta na estimação dos parâmetros de interesse, como os coeficientes dos modelos lineares mistos. Exemplos de parâmetros perturbadores no contexto deste trabalho são as variabilidades por participante e por item dos experimentos de prime considerados.”<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Você pode ver o post completo aqui <a href="http://talklab.psy.gla.ac.uk/tvw/catpred/" class="uri">http://talklab.psy.gla.ac.uk/tvw/catpred/</a>.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Na internet, um bom material são os slides de Scott Fraundorf: <a href="http://www.lrdc.pitt.edu/maplelab/slides/Simple_Main_Effects_Fraundorf.pdf" class="uri">http://www.lrdc.pitt.edu/maplelab/slides/Simple_Main_Effects_Fraundorf.pdf</a>.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Acesse em <a href="https://stats.stackexchange.com/" class="uri">https://stats.stackexchange.com/</a>.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Acesse em <a href="https://pt.stackoverflow.com/" class="uri">https://pt.stackoverflow.com/</a> para fóruns em português e <a href="https://stackoverflow.com/questions" class="uri">https://stackoverflow.com/questions</a> para fóruns em inglês.<a href="#fnref8">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="assets/gitbook-2.6.7/js/app.min.js"></script>
<script src="assets/gitbook-2.6.7/js/lunr.js"></script>
<script src="assets/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="assets/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="assets/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="assets/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="assets/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="assets/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="assets/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"toolbar": {
"position": "static"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
